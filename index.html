<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Strive Dungeon Generator</title>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Crimson+Text:ital,wght@0,400;0,600;1,400&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-dark: #0d0d0f;
            --bg-card: #16161a;
            --bg-card-hover: #1c1c22;
            --border: #2a2a35;
            --text-primary: #e8e6e3;
            --text-muted: #8b8680;
            --accent-gold: #c9a227;
            --accent-gold-dim: #8b7119;
            --accent-red: #8b2635;
            --accent-green: #2d5a27;
            --accent-blue: #1e3a5f;
            --danger: #6b1e1e;
            --font-display: 'Cinzel', serif;
            --font-body: 'Crimson Text', serif;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-body);
            background: var(--bg-dark);
            color: var(--text-primary);
            min-height: 100vh;
            line-height: 1.6;
            background-image: 
                radial-gradient(ellipse at 20% 0%, rgba(201, 162, 39, 0.03) 0%, transparent 50%),
                radial-gradient(ellipse at 80% 100%, rgba(139, 38, 53, 0.03) 0%, transparent 50%);
        }

        .container {
            max-width: 2000px;
            width: min(2000px, 96vw);
            margin: 0 auto;
            padding: 2rem;
        }

        header {
            text-align: center;
            margin-bottom: 3rem;
            padding: 2rem 0;
            border-bottom: 1px solid var(--border);
        }

        h1 {
            font-family: var(--font-display);
            font-size: 2.5rem;
            color: var(--accent-gold);
            letter-spacing: 0.15em;
            text-transform: uppercase;
            margin-bottom: 0.5rem;
            text-shadow: 0 0 40px rgba(201, 162, 39, 0.3);
        }

        .subtitle {
            color: var(--text-muted);
            font-style: italic;
            font-size: 1.1rem;
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1.5rem;
            margin-bottom: 1.5rem;
            padding: 1.5rem;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 4px;
        }

        .setup-panel {
            margin-bottom: 2rem;
            border: 1px solid var(--border);
            border-radius: 4px;
            background: var(--bg-card);
        }

        .setup-panel summary {
            cursor: pointer;
            padding: 1rem 1.5rem;
            font-family: var(--font-display);
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 0.15em;
            color: var(--accent-gold);
            list-style: none;
        }

        .setup-panel summary::-webkit-details-marker {
            display: none;
        }

        .setup-panel[open] summary {
            border-bottom: 1px solid var(--border);
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .control-group.full-width {
            grid-column: 1 / -1;
        }

        label {
            font-family: var(--font-display);
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--text-muted);
        }

        input, select {
            background: var(--bg-dark);
            border: 1px solid var(--border);
            color: var(--text-primary);
            padding: 0.75rem 1rem;
            font-family: var(--font-body);
            font-size: 1rem;
            border-radius: 2px;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        input:focus, select:focus {
            outline: none;
            border-color: var(--accent-gold-dim);
            box-shadow: 0 0 0 2px rgba(201, 162, 39, 0.1);
        }

        input[type="file"] {
            padding: 0.5rem;
        }

        .keyword-group {
            margin-bottom: 0.5rem;
        }

        .keyword-row {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        .keyword-input {
            flex: 0 0 120px;
            min-width: 100px;
        }

        .ability-input {
            flex: 1;
            min-width: 140px;
        }

        .buttons {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            margin-bottom: 2rem;
        }

        button {
            font-family: var(--font-display);
            font-size: 0.8rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            padding: 1rem 1.5rem;
            border: 1px solid var(--border);
            background: var(--bg-card);
            color: var(--text-primary);
            cursor: pointer;
            transition: all 0.2s;
            border-radius: 2px;
        }

        button:hover {
            background: var(--bg-card-hover);
            border-color: var(--accent-gold-dim);
        }

        button.primary {
            background: linear-gradient(135deg, var(--accent-gold-dim), var(--accent-gold));
            color: var(--bg-dark);
            border-color: var(--accent-gold);
            font-weight: 700;
        }

        button.primary:hover {
            box-shadow: 0 0 20px rgba(201, 162, 39, 0.3);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .main-content {
            display: grid;
            grid-template-columns: minmax(550px, 1.3fr) minmax(520px, 1fr);
            gap: 2rem;
        }

        @media (max-width: 900px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }

        .current-room {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 4px;
            overflow: hidden;
        }

        .room-header {
            background: linear-gradient(90deg, var(--accent-gold-dim), transparent);
            padding: 1rem 1.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .room-number {
            font-family: var(--font-display);
            font-size: 1.2rem;
            color: var(--accent-gold);
        }

        .room-badge {
            font-family: var(--font-display);
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.15em;
            padding: 0.4rem 0.8rem;
            background: var(--danger);
            border-radius: 2px;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .room-body {
            padding: 1.5rem;
        }

        .room-meta {
            display: flex;
            gap: 1.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--border);
            flex-wrap: wrap;
        }

        .meta-item {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        .meta-label {
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--text-muted);
        }

        .meta-value {
            font-size: 0.95rem;
            color: var(--accent-gold);
        }

        .room-description {
            font-size: 1.15rem;
            line-height: 1.8;
            margin-bottom: 1.5rem;
            padding: 1rem;
            background: rgba(0,0,0,0.3);
            border-left: 3px solid var(--accent-gold-dim);
            font-style: italic;
        }

        .section-title {
            font-family: var(--font-display);
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 0.15em;
            color: var(--accent-gold);
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border);
        }

        .exits {
            margin-bottom: 1.5rem;
        }

        .exit-list {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .exit-item {
            padding: 0.75rem 1rem;
            background: rgba(0,0,0,0.2);
            border-radius: 2px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        .exit-direction {
            font-family: var(--font-display);
            font-weight: 700;
            min-width: 60px;
        }

        .exit-status {
            flex: 1;
        }

        .exit-status.open { color: var(--accent-green); }
        .exit-status.blocked { color: var(--accent-red); }

        .bypass-info {
            font-size: 0.9rem;
            color: var(--text-muted);
            width: 100%;
            margin-top: 0.25rem;
            padding-left: 70px;
        }

        .trap-damage {
            color: var(--accent-red);
            font-weight: bold;
            margin-top: 0.25rem;
        }

        .threats {
            margin-bottom: 1rem;
        }

        .loot {
            margin-bottom: 1rem;
        }

        .loot-list {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        .loot-block {
            background: rgba(201, 162, 39, 0.08);
            border: 1px solid rgba(201, 162, 39, 0.3);
            border-radius: 4px;
            padding: 0.5rem 0.75rem;
            display: flex;
            align-items: baseline;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        .loot-block h4 {
            font-family: var(--font-display);
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--accent-gold);
            margin: 0;
        }

        .loot-items {
            display: flex;
            flex-wrap: wrap;
            gap: 0.25rem 0.5rem;
            font-size: 0.9rem;
            color: var(--text-primary);
        }

        .loot-item {
            display: inline-flex;
            gap: 0.35rem;
            align-items: baseline;
        }

        .loot-tag {
            font-size: 0.65rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            padding: 0.1rem 0.3rem;
            border-radius: 2px;
            background: rgba(0, 0, 0, 0.4);
            color: var(--text-muted);
        }

        .loot-tag.common { color: #e5d7a3; }
        .loot-tag.rare { color: #9fd1ff; }
        .loot-tag.legendary { color: #f4b4ff; }

        .threat-list {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .threat-block {
            background: rgba(139, 38, 53, 0.1);
            border: 1px solid var(--accent-red);
            border-radius: 4px;
            padding: 1rem;
        }

        .threat-block.boss {
            background: linear-gradient(135deg, rgba(139, 38, 53, 0.2), rgba(201, 162, 39, 0.1));
            border-color: var(--accent-gold);
            box-shadow: 0 0 20px rgba(201, 162, 39, 0.1);
        }

        .threat-header {
            font-family: var(--font-display);
            font-size: 1.1rem;
            color: var(--text-primary);
            margin-bottom: 0.75rem;
        }

        .threat-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 0.5rem;
            margin-bottom: 0.75rem;
            font-size: 0.9rem;
        }

        .threat-stat {
            display: flex;
            gap: 0.5rem;
        }

        .stat-label {
            color: var(--text-muted);
        }

        .threat-abilities {
            padding-top: 0.5rem;
            border-top: 1px solid rgba(139, 38, 53, 0.3);
        }

        .ability {
            font-size: 0.9rem;
            color: var(--text-muted);
            padding: 0.25rem 0;
        }

        .ability-name {
            color: var(--accent-gold);
        }

        .no-threats {
            color: var(--text-muted);
            font-style: italic;
            padding: 1rem;
            text-align: center;
            background: rgba(0,0,0,0.2);
            border-radius: 2px;
        }

        .empty-state {
            padding: 3rem 1.5rem;
            text-align: center;
            color: var(--text-muted);
        }

        .empty-state p {
            margin-bottom: 1rem;
        }

        .data-status {
            font-size: 0.85rem;
            color: var(--text-muted);
            padding: 0.5rem 1rem;
            background: rgba(0,0,0,0.3);
            border-radius: 2px;
            margin-bottom: 1rem;
        }

        .data-status.loaded {
            color: var(--accent-green);
            border-left: 3px solid var(--accent-green);
        }

        .data-status.default {
            border-left: 3px solid var(--accent-gold-dim);
        }

        .data-status.warning {
            color: var(--accent-red);
            border-left: 3px solid var(--accent-red);
        }

        .error {
            background: var(--danger);
            padding: 1rem;
            border-radius: 4px;
            margin-bottom: 1rem;
        }

        .potency-competent { color: #6b9b6b; }
        .potency-effective { color: #9b9b6b; }
        .potency-forceful { color: #9b6b6b; }

        .hidden { display: none !important; }

        .exit-actions {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
            margin-left: auto;
        }

        .exit-action {
            font-size: 0.65rem;
            padding: 0.4rem 0.6rem;
        }

        .map-panel {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 4px;
            overflow: hidden;
        }

        .map-header {
            padding: 1rem 1.5rem;
            background: rgba(0,0,0,0.3);
            font-family: var(--font-display);
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 0.15em;
            color: var(--accent-gold);
            border-bottom: 1px solid var(--border);
        }

        .map-body {
            padding: 1rem;
        }

        .map-grid {
            position: relative;
            background-image:
                linear-gradient(transparent 69px, rgba(255, 255, 255, 0.05) 70px),
                linear-gradient(90deg, transparent 69px, rgba(255, 255, 255, 0.05) 70px);
            background-size: 70px 70px;
            border: 1px solid var(--border);
            border-radius: 2px;
            overflow: auto;
            min-height: 220px;
        }

        .map-rooms {
            position: relative;
        }

        .map-room {
            position: absolute;
            width: var(--room-size, 140px);
            height: var(--room-size, 140px);
            border: 1px solid rgba(201, 162, 39, 0.3);
            border-radius: 2px;
            overflow: hidden;
            box-shadow: 0 0 10px rgba(0,0,0,0.4);
        }

        .map-room img {
            width: 100%;
            height: 100%;
            transform-origin: center;
        }

        .map-room.current {
            outline: 3px solid var(--accent-gold);
            box-shadow: 0 0 20px rgba(201, 162, 39, 0.4);
        }

        .map-room.start {
            outline: 2px dashed var(--accent-green);
        }

        .map-room.boss {
            outline: 2px solid var(--accent-red);
        }

        .map-room-label {
            position: absolute;
            bottom: 4px;
            left: 4px;
            padding: 0.2rem 0.4rem;
            background: rgba(0,0,0,0.6);
            font-size: 0.65rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .map-room-label span {
            color: var(--accent-gold);
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Strive Dungeon</h1>
            <p class="subtitle">GM-less Procedural Dungeon Generator</p>
        </header>

        <div id="dataStatus" class="data-status default">Using default embedded data. Load a custom JSON file to override.</div>
        <div id="errorDisplay" class="error hidden"></div>

        <details class="setup-panel" open>
            <summary>Dungeon Setup</summary>
            <div class="controls">
                <div class="control-group">
                    <label for="difficulty">Difficulty</label>
                    <select id="difficulty">
                        <option value="Easy">Easy</option>
                        <option value="Medium" selected>Medium</option>
                        <option value="Hard">Hard</option>
                        <option value="Deadly">Deadly</option>
                    </select>
                </div>
                <div class="control-group">
                    <label for="dungeonLength">Dungeon Length (rooms)</label>
                    <input type="number" id="dungeonLength" min="6" max="30" value="10">
                </div>
                <div class="control-group full-width keyword-group">
                    <label>Threat Keyword 1</label>
                    <div class="keyword-row">
                        <input type="text" id="threatKeyword1" placeholder="e.g., Goblin" class="keyword-input">
                        <input type="text" id="keywordAbility1_1" list="abilityList" placeholder="Ability 1" class="ability-input">
                        <input type="text" id="keywordAbility1_2" list="abilityList" placeholder="Ability 2" class="ability-input">
                        <input type="text" id="keywordAbility1_3" list="abilityList" placeholder="Ability 3" class="ability-input">
                    </div>
                </div>
                <div class="control-group full-width keyword-group">
                    <label>Threat Keyword 2 (optional)</label>
                    <div class="keyword-row">
                        <input type="text" id="threatKeyword2" placeholder="e.g., Ogre" class="keyword-input">
                        <input type="text" id="keywordAbility2_1" list="abilityList" placeholder="Ability 1" class="ability-input">
                        <input type="text" id="keywordAbility2_2" list="abilityList" placeholder="Ability 2" class="ability-input">
                        <input type="text" id="keywordAbility2_3" list="abilityList" placeholder="Ability 3" class="ability-input">
                    </div>
                </div>
                <datalist id="abilityList"></datalist>
                <div class="control-group">
                    <label for="dataFile">Import Data File</label>
                    <input type="file" id="dataFile" accept=".json">
                </div>
                <div class="control-group">
                    <label for="pngFolder">Load PNG Folder</label>
                    <input type="file" id="pngFolder" webkitdirectory directory>
                </div>
            </div>

            <div class="buttons">
                <button class="primary" id="startBtn">Start New Dungeon</button>
                <button id="exportBtn" disabled>Export Dungeon (JSON)</button>
            </div>
        </details>

        <div class="main-content">
            <div class="current-room" id="currentRoomPanel">
                <div class="empty-state" id="emptyState">
                    <p>No dungeon started yet.</p>
                    <p>Configure your settings above and click "Start New Dungeon" to begin.</p>
                </div>
                <div id="roomContent" class="hidden"></div>
            </div>

            <div class="map-panel">
                <div class="map-header">Dungeon Map</div>
                <div class="map-body">
                    <div id="mapEmpty" class="empty-state">
                        <p>Rooms will reveal themselves here as you explore.</p>
                    </div>
                    <div id="pngStatus" class="data-status default hidden"></div>
                    <div id="mapGrid" class="map-grid hidden">
                        <div id="mapRooms" class="map-rooms"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ==================== DEFAULT DATA ====================
        const DEFAULT_DATA = {
            roomTypes: ["chamber", "alcove", "vault", "crypt", "gallery", "sanctum", "antechamber", "hall", "passage", "den", "lair", "pit", "shrine", "cellar", "cave"],
            leadIns: ["You enter", "Before you lies", "You step into", "Ahead stretches", "You discover", "Opening before you is", "You find yourself in", "Emerging into", "Through the doorway lies"],
            sensesUnderfoot: ["cracked flagstones shift beneath your feet", "soft earth muffles your steps", "bones crunch underfoot", "slick moss covers the floor", "loose gravel scatters with each step", "ancient tiles lie broken and uneven", "thick dust coats every surface", "shallow water pools on the floor", "dried leaves crackle beneath you", "rough-hewn stone chills your soles"],
            sensesAir: ["a musty dampness hangs in the air", "cold drafts whisper through unseen cracks", "stale air fills your lungs", "a faint acrid smell burns your nostrils", "the scent of decay lingers", "dry dusty air catches in your throat", "a metallic tang permeates the space", "cool air suggests hidden depths nearby", "warm humid air presses against you"],
            sensesSound: ["distant dripping echoes", "an unnatural silence presses in", "faint scratching sounds from the walls", "your breath echoes back at you", "a low hum vibrates through the stone", "whispers seem to dance at the edge of hearing", "creaking sounds from above", "the soft rustle of unseen movement", "water trickles somewhere nearby"],
            sensesLight: ["dim light filters from cracks above", "absolute darkness swallows everything", "phosphorescent fungi cast an eerie glow", "your torchlight barely penetrates the gloom", "strange shadows dance without source", "pale light seeps from the walls themselves", "flickering braziers line the walls", "a single shaft of light pierces the darkness", "bioluminescent lichen traces the ceiling"],
            interactions: ["dominating the space", "crumbling with age", "covered in strange markings", "partially collapsed", "surprisingly intact", "recently disturbed", "webbed with cracks", "slick with moisture", "scorched by ancient fire"],
            anchorFeatures: ["A massive stone altar", "Towering pillars", "A dry fountain", "Collapsed scaffolding", "An iron cage", "Stacked crates and barrels", "A ritual circle", "Broken statuary", "A deep pit", "Thick chains", "A wooden platform", "Ancient machinery", "Piled rubble", "A raised dais", "Ornate sarcophagi"],
            pressures: ["The ceiling groans ominously", "Cracks spread across the floor", "The air grows thin", "Strange symbols pulse with light", "The walls seem to close in", "Noxious fumes seep from vents", "Unstable magic crackles", "The ground trembles faintly", "Shadows move independently"],
            mitigations: ["reveal a safe path", "disable the mechanism", "find stable footing", "dispel the effect", "locate an escape route", "neutralize the danger", "identify the source", "calm the disturbance", "spot the trigger"],
            doorStatuses: ["Open", "Stuck", "Locked", "Jammed", "Barred", "Trapped", "Sealed", "Collapsed"],
            doorBypassVerbs: {
                "Stuck": { verbs: ["force", "pry", "shoulder"] },
                "Locked": { verbs: ["pick", "bypass", "decode"] },
                "Jammed": { verbs: ["wrench", "lever", "force"] },
                "Barred": { verbs: ["break", "lift", "smash"] },
                "Trapped": { verbs: ["disarm", "bypass", "disable"] },
                "Sealed": { verbs: ["decipher", "unravel", "break"] },
                "Collapsed": { verbs: ["clear", "dig through", "move"] }
            },
            typeWords: ["Archer", "Brute", "Skirmisher", "Elite", "Shaman", "Scout", "Defender", "Lurker", "Caster"],
            wordToAbility: {
                "Archer": "Volley: This threat deals half of its damage (rounded up) to 2 targets in Short range.",
                "Brute": "Berserker: Even if this threat is Overwhelmed, it still deals half of its damage (rounded up).",
                "Skirmisher": "Slippery: Any attempt to restrain, pin, or otherwise immobilise this threat requires an additional success.",
                "Elite": "Sword-master: When you Push a Fight roll against this threat while in Touch range, you immediately lose 1d6 Grit.",
                "Shaman": "Conjurer: Instead of dealing damage, this threat can summon an elemental to fight at its side.",
                "Scout": "Ambusher: Unless spotted beforehand by an Effective observational check against this threat's Success Threshold, characters are Surprised when it initiates combat.",
                "Defender": "Shielded: When a check would assign successes to this threat, reduce the assigned successes by 1.",
                "Lurker": "Escape Artist: At the end of each round, if this threat isn't Overwhelmed and isn't restrained (pinned, trapped, magically bound, etc.), it escapes.",
                "Caster": "Arcane Defense: Within Short range, magic checks affecting this threat require two additional success to achieve the desired potency."
            },
            typeRange: {
                "Archer": "Ranged",
                "Brute": "Melee",
                "Skirmisher": "Melee and Ranged",
                "Elite": "Melee",
                "Shaman": "Ranged",
                "Scout": ["Melee", "Ranged"],
                "Defender": "Melee",
                "Lurker": "Melee",
                "Caster": "Ranged"
            },
            striveAbilities: [
                "Acidic Blood: When a PC assigns successes to this threat while in Touch range, that PC loses 2 Grit.",
                "Ambusher: Unless spotted beforehand by an Effective observational check against this threat's Success Threshold, characters are Surprised when it initiates combat.",
                "Armoured (2): This Threat is unaffected by checks and successes less potent than Effective.",
                "Armoured (3): This Threat is unaffected by checks and successes less potent than Forceful.",
                "Anti-magic: Within Short range, magic checks require an additional success to achieve the desired potency.",
                "Arcane Defense: Within Short range, magic checks affecting this threat require two additional success to achieve the desired potency.",
                "Arcanist: Instead of dealing damage, this threat can wield magic to majorly impact the combat at a forceful potency.",
                "Berserker: Even if this threat is Overwhelmed, it still deals half of its damage (rounded up).",
                "Besiege: Instead of dealing damage, this threat forces open a gate or doorway.",
                "Bound: If conjured, the conjurer can command the threat at no focus cost, can use the threat's senses as if they are its own, and can communicate by taking command of it's mouth, even at beyond distance. If the threat is defeated, its conjurer takes 1 damage to their focus. A conjurer can only be bound to one threat at a time.",
                "Conjurer: Instead of dealing damage, this threat can summon an elemental to fight at its side.",
                "Cowardly: If at least 1 success has been assigned against this threat this round, it attempts to flee instead of dealing damage—unless an allied leader or at least 3 other allies are in Short range.",
                "Crew: This Threat deals double successes to other Threats. When the defeat tier is reached, this threat splits into several lesser threats at the end of the round.",
                "Crush: A creature Restrained by this threat (can't move away) loses 2d6 Grit at the start of its turn.",
                "Dark Incantation: Instead of dealing damage, this threat advances a dark ritual. If it isn't Overwhelmed within 3 rounds, the ritual completes and triggers a Devastating/Apocalyptic effect.",
                "Death Wave: When this threat is Defeated (not Overwhelmed), each PC in Touch range loses 1d6 Grit.",
                "Enrage: This threat's damage increases by 1d6 for each round of combat.",
                "Escape Artist: At the end of each round, if this threat isn't Overwhelmed and isn't restrained (pinned, trapped, magically bound, etc.), it escapes.",
                "Ethereal: Non-magical actions cannot affect this threat unless it is anchored in the physical world. A PC may Anchor it with a suitable Major Impact action (Effective potency) until the end of the next round.",
                "Fearsome Presence: At the start of your turn, if within Short range, make an Effective potency Mind check against this threat's Success Threshold; on failure, you can't Push your rolls this turn.",
                "Fire Immunity: This threat ignores successes dealt with fire.",
                "Fire Vulnerability: Attacking this threat with fire grants an additional success.",
                "Flame Aura: When you assign successes to this threat while in Touch range, you lose 1d6 Grit.",
                "Flaming Breath (2d6): Unless surprised, this threat opens the combat by dealing 2d6 damage against all creatures in Short range, unless they succeed on a relevant check at Effective potency.",
                "Flaming Breath (3d6): Unless surprised, this threat opens the combat by dealing 3d6 damage against all creatures in Short range, unless they succeed on a relevant check at Forceful potency.",
                "Flying: Cannot be targeted by non-ranged checks unless this threat is grounded. A PC may ground it with a suitable Major Impact action (Effective) until the end of the round.",
                "Focus Fire: Instead of dealing damage to multiple targets, this threat deals 3d6 damage to a single target. This can only be used when there are no enemies in touch range of this threat.",
                "Forest's Protection: Checks to Major Impact this threat require two additional success to achieve the desired potency.",
                "Foul: At the start of combat, each PC in Short range makes a Competent Mind check against this threat's Success Threshold; on failure, lose 1 Focus.",
                "Foul (2): At the start of your turn, while in Short range, make a Competent Mind check against this threat's Success Threshold; on failure, lose 1 Focus.",
                "Grapple & Pin: Instead of dealing damage, this threat attempts to Pin a creature in Touch range. The target makes an Effective Body check against this threat's Success Threshold; on failure they are Pinned (can't move or act except in attempts to break free) until they succeed on a Forceful Body check against this threat's Success Threshold at the start of their turn.",
                "Grappler: When this threat deals damage to you in Touch range, you become Restrained (can't move away) until the end of your next turn unless you succeed on a Competent Body check against this threat's Success Threshold.",
                "Grappler (2): Instead of dealing damage, this threat attempts to Restrain its target(s). Each target makes a Forceful Body check against this threat's Success Threshold; on failure they are Restrained (can't move away) until they succeed on an Effective Body check against this threat's Success Threshold at the start of their turn.",
                "Grappler (All): Instead of dealing damage, this threat attempts to Restrain every PC in Touch range. Each target makes an Effective Body check against this threat's Success Threshold; on failure they are Restrained (can't move away) until they succeed on an Effective Body check against this threat's Success Threshold at the start of their turn.",
                "Group: If this threat is part of a stack of 3 or more threats, it can use all of its non-damaging abilities in addition to dealing half of its damage to each of its targets.",
                "Heedless: This threat has no Defeat Tier and must be Overwhelmed to be defeated.",
                "Horde: This threat can use all of its non-damaging abilities and still deals half of its damage to each of its targets.",
                "Hurl: Instead of dealing damage in melee, this threat deals its damage to one target up to Far range.",
                "Hypnotic: At the start of your turn in Short range, make an Effective Mind check against this threat's Success Threshold; on failure, you're Stunned until the end of your turn. Once you succeed, you are immune to this ability for the rest of the scene.",
                "Ice Immunity: This threat ignores successes dealt with ice.",
                "Ice Vulnerability: Attacking this threat with ice grants an additional success.",
                "Ice-bite: Damage from this threat leaves the skin feeling cold and numb for days. If left untreated for several days, it turns into frostbite.",
                "Illusory Doubles: This threat has a number of illusions equal to its success threshold. When targeting this threat, the players roll 1d6. If the number is below the threat's Success Threshold, and has not been rolled already against this threat, they strike an illusion instead.",
                "Indulgent: So long as it isn't disturbed, this threat may let others pass without taking notice.",
                "Lightning Immunity: This threat ignores successes dealt with lightning.",
                "Lightning Vulnerability: Attacking this threat with lightning grants an additional success.",
                "Meat Shield: If this threat has allies in touch range, the first success dealt against it is dealt to an ally instead.",
                "Mental Drain: Whenever a PC within Short range makes a magic check, they lose 1 Focus.",
                "Mind-breaker: This threat deals damage to Focus instead of Grit.",
                "Poisonous: If a player takes damage from this threat, they take another instance of that damage after an hour.",
                "Poisonous (1): If a player takes damage from this threat, they are Poisoned. At the end of their turn, they lose 1 Grit until they succeed a Competent Body check (Threshold 4) or receive treatment.",
                "Potent Poison: If a player takes damage from this threat, they are Poisoned. At the end of their turn, they lose 1d6 Grit until they succeed an Effective Body check (Threshold 4) or receive treatment.",
                "Power-words: Instead of dealing damage, this threat speaks a Word at a target in Short range. The target makes an Effective Mind check against this threat's Success Threshold; on failure they suffer a Forceful-tier effect appropriate to the Word (GM call) until the end of their next turn.",
                "Pursuer: An additional two successes are required to flee from this threat.",
                "Reassembling: Unless this threat's remains are burned and scattered, it shortly reassembles, all successes removed.",
                "Reflective Hide: When you assign three or more successes to this threat from a single check, you take 1d6 damage to your Grit.",
                "Regeneration: At the end of each round, remove all accumulated successes from this threat.",
                "Regeneration (Numerical): At the end of each round, remove accumulated successes equal to this threat's Success Threshold.",
                "Second Stage: When this threat would be defeated, its second stage is revealed.",
                "Second Stage (Strive): When this threat would be defeated, its second stage is revealed, and each player regains a Strive Die.",
                "Shielded: When a check would assign successes to this threat, reduce the assigned successes by 1.",
                "Slippery: Any attempt to restrain, pin, or otherwise immobilise this threat requires an additional success.",
                "Slow: Defend & Flee checks to escape this threat are set to Competent (1 success), unless the GM rules otherwise.",
                "Smother: Instead of dealing damage, this threat smothers all light sources in Short range, until relit.",
                "Squeeze: A creature Restrained by this threat (can't move away) loses 1d6 Grit at the start of its turn.",
                "Stone Skin: Non-magical checks treat this threat's Success Threshold as 5 (even if it is normally lower).",
                "Suppressing Shot: The first target to push a roll within far range of this threat immediately takes 1d6 damage.",
                "Sword-master: When you Push a Fight roll against this threat while in Touch range, you immediately lose 1d6 Grit.",
                "Teamwork: This threat immediately deals 1d6 damage to touch range targets that attack a nearby allied threat.",
                "Teleport (Short Range): At the end of each round, if this threat isn't Overwhelmed and isn't restrained/anchored, it teleports away up to Short range.",
                "Teleport (Beyond): At the end of each round, if this threat isn't Overwhelmed and isn't restrained/anchored, it teleports away up to Beyond range.",
                "Volley: This threat deals half of its damage (rounded up) to 2 targets in Short range.",
                "Water Immunity: This threat ignores successes dealt with water.",
                "Water Vulnerability: Attacking this threat with water grants an additional success."
            ],
            keywordAbilityInputMax: 3,
            difficultyProfiles: {
                "Easy": {
                    potencyWeights: { "Competent": 60, "Effective": 30, "Forceful": 10 },
                    trapDamage: { min: 1, max: 1 },
                    successTiers: { defeat: 2, overwhelm: 4 },
                    baseThresholdRange: { min: 3, max: 4 },
                    damageRange: { min: 1, max: 1 },
                    threatTypesRange: { min: 0, max: 2 },
                    quantityRange: { min: 1, max: 2 },
                    maxThreatsPerRoom: 3,
                    keywordAbilityChance: 0.1,
                    bossDefeatBonus: 5,
                    bossOverwhelmBonus: 6,
                    bossDamageBonus: 1
                },
                "Medium": {
                    potencyWeights: { "Competent": 25, "Effective": 50, "Forceful": 25 },
                    trapDamage: { min: 1, max: 2 },
                    successTiers: { defeat: 5, overwhelm: 7 },
                    baseThresholdRange: { min: 3, max: 4 },
                    damageRange: { min: 1, max: 2 },
                    threatTypesRange: { min: 1, max: 2 },
                    quantityRange: { min: 1, max: 3 },
                    maxThreatsPerRoom: 4,
                    keywordAbilityChance: 0.25,
                    bossDefeatBonus: 6,
                    bossOverwhelmBonus: 8,
                    bossDamageBonus: 1
                },
                "Hard": {
                    potencyWeights: { "Competent": 10, "Effective": 45, "Forceful": 45 },
                    trapDamage: { min: 1, max: 2 },
                    successTiers: { defeat: 8, overwhelm: 12 },
                    successTiersWeak: { defeat: 5, overwhelm: 7 },
                    baseThresholdRange: { min: 4, max: 5 },
                    damageRange: { min: 1, max: 2 },
                    threatTypesRange: { min: 1, max: 3 },
                    quantityRange: { min: 2, max: 3 },
                    maxThreatsPerRoom: 6,
                    keywordAbilityChance: 0.5,
                    bossDefeatBonus: 6,
                    bossOverwhelmBonus: 8,
                    bossDamageBonus: 2
                },
                "Deadly": {
                    potencyWeights: { "Competent": 5, "Effective": 30, "Forceful": 65 },
                    trapDamage: { min: 2, max: 3 },
                    successTiers: { defeat: 16, overwhelm: 24 },
                    successTiersWeak: { defeat: 8, overwhelm: 12 },
                    baseThresholdRange: { min: 4, max: 5 },
                    damageRange: { min: 2, max: 3 },
                    threatTypesRange: { min: 2, max: 3 },
                    maxThreatsPerRoom: 8,
                    quantityRange: { min: 2, max: 4 },
                    keywordAbilityChance: 0.75,
                    bossDefeatBonus: 8,
                    bossOverwhelmBonus: 10,
                    bossDamageBonus: 2
                }
            },
            layouts: {
                Rooms: ["A1", "A3", "A4", "E2", "N1", "N2", "NE1", "NE2", "NS2", "S4"],
                Halls: ["A2", "E1", "E3", "E4", "N3", "N4", "NS1", "S1", "S2", "S3"],
                "Dead Ends": ["D1", "D2", "D3", "D4"]
            },
            entranceLayouts: {
                "ENT_E": ["E"],
                "ENT_NS": ["N", "S"],
                "ENT_NW": ["N", "W"],
                "ENT_NWS": ["N", "W", "S"]
            },
            layoutExits: {
                "A": ["N", "E", "S"],
                "N": ["N"],
                "E": ["E"],
                "S": ["S"],
                "NE": ["N", "E"],
                "NS": ["N", "S"],
                "D": []
            }
        };

        const LOOT_DATA = {
            magic: {
                Common: {
                    potions: ["Focus Potion", "Healing Potion"],
                    items: [
                        "Focus Beads", "Grit Gloves", "Grappling Hook Gauntlet", "Common Arcane Conduit",
                        "Torch-stone", "Discouraging Fragrance", "Hunter’s Toxin", "Keen-Eye Lens",
                        "Soft-Step Wax", "Smoke Pellet", "Quicklime Chalk", "Climbing Spikes",
                        "Flash-Glass", "Field Stitch Kit", "Whisper-Coin", "Rust-Eater Vial"
                    ]
                },
                Rare: {
                    potions: ["Potent Focus Potion", "Potent Healing Potion", "Wound-Salve"],
                    items: [
                        "Ring of Featherlight", "Rare Arcane Conduit", "Cloak of Shadows",
                        "Warding Aegis", "Venom-strike (Weapon)", "Extradimensional Storage Pouch",
                        "Warded Cloak", "Arcane Armour", "Lantern of True Forms",
                        "Blink Charm", "Spell-Sunder Bindings", "Oath-Thread Bracelet",
                        "Mindward Circlet", "Grasping Chain", "Siphoning Vambrace"
                    ]
                },
                Legendary: {
                    potions: ["Legendary Focus Potion", "Legendary Healing Potion"],
                    items: [
                        "Legendary Arcane Conduit", "Storm-enchanted Weapon", "Legendary Arcane Armour",
                        "Crown of the Unbroken", "Gatekey", "Blade of Echoes (Weapon)",
                        "Mantle of the Deep Step", "Hourglass Locket",
                        "Sigil of Dominion", "Aegis of Iron Vows"
                    ]
                }
            },
            mundane: {
                equipment: [
                    "Shield and arm strap", "Steel longsword", "Hardened spear",
                    "Shortbow with 20 arrows", "Chain shirt", "Leather armor",
                    "Iron lantern", "Crowbar", "Lockpick set",
                    "Grapple and rope (50 ft)", "Piton kit (10 spikes + hammer)"
                ],
                supplies: [
                    "Rations (3 days)", "Water skin", "Torch bundle (6)",
                    "Oil flask", "Bandages and salves", "Chalk sticks",
                    "Bedroll", "Climbing harness"
                ],
                trinkets: [
                    "Silvered locket with a faded portrait", "Carved bone die",
                    "Tiny brass astrolabe", "Ring of braided copper wire",
                    "Faded battle pennant", "Ivory comb with sigil",
                    "Glass vial of glittering sand", "Child’s tin whistle"
                ],
                gemstones: [
                    "Polished agate (10 coins)", "Deep-blue lapis (25 coins)",
                    "Cracked ruby chip (50 coins)", "Moonstone shard (40 coins)",
                    "Cut emerald sliver (75 coins)", "Amber bead with fossil (30 coins)"
                ]
            }
        };

        const LOOT_RARITY_WEIGHTS = {
            Easy: { Common: 85, Rare: 13, Legendary: 2 },
            Medium: { Common: 72, Rare: 23, Legendary: 5 },
            Hard: { Common: 58, Rare: 32, Legendary: 10 },
            Deadly: { Common: 45, Rare: 38, Legendary: 17 }
        };

        // ==================== STATE ====================
        let gameData = JSON.parse(JSON.stringify(DEFAULT_DATA));
        let dungeonState = null;
        let usedLayouts = { Rooms: [], Halls: [], "Dead Ends": [] };
        const pngCache = {};
        const missingPngPaths = new Set();
        const directionVectors = {
            N: { x: 0, y: -1 },
            E: { x: 1, y: 0 },
            S: { x: 0, y: 1 },
            W: { x: -1, y: 0 }
        };

        // ==================== UTILITIES ====================
        function randInt(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        function pick(arr) {
            return arr[Math.floor(Math.random() * arr.length)];
        }

        function weightedPick(weights) {
            const total = Object.values(weights).reduce((a, b) => a + b, 0);
            let r = Math.random() * total;
            for (const [key, weight] of Object.entries(weights)) {
                r -= weight;
                if (r <= 0) return key;
            }
            return Object.keys(weights)[0];
        }

        function clampRarityWeights(weights) {
            const clamped = { ...weights };
            Object.keys(clamped).forEach(key => {
                if (clamped[key] < 1) clamped[key] = 1;
            });
            return clamped;
        }

        function adjustRarityWeights(baseWeights, hasEncounter, isBoss) {
            const adjusted = { ...baseWeights };
            if (hasEncounter) {
                adjusted.Common -= 10;
                adjusted.Rare += 7;
                adjusted.Legendary += 3;
            }
            if (isBoss) {
                adjusted.Common -= 10;
                adjusted.Rare += 5;
                adjusted.Legendary += 5;
            }
            return clampRarityWeights(adjusted);
        }

        function formatCoins(coins) {
            if (!coins) return '';
            const parts = [];
            if (coins.gp) parts.push(`${coins.gp} gp`);
            if (coins.sp) parts.push(`${coins.sp} sp`);
            if (coins.cp) parts.push(`${coins.cp} cp`);
            return parts.length > 0 ? parts.join(', ') : `${coins.total} coins`;
        }

        function article(word) {
            // Returns "a" or "an" based on whether the word starts with a vowel sound
            const vowels = ['a', 'e', 'i', 'o', 'u'];
            const firstLetter = word.trim().toLowerCase().charAt(0);
            return vowels.includes(firstLetter) ? 'an' : 'a';
        }

        function getLayoutCode(layoutId) {
            const match = layoutId.match(/^([A-Z]+)/);
            return match ? match[1] : "D";
        }

        function getExitsForLayout(layoutId) {
            const code = getLayoutCode(layoutId);
            return gameData.layoutExits[code] || [];
        }

        function coordKey(x, y) {
            return `${x},${y}`;
        }

        function getOppositeDirection(dir) {
            const opposites = { N: 'S', S: 'N', E: 'W', W: 'E' };
            return opposites[dir];
        }

        function getRotationForMove(moveDir) {
            const rotations = { E: 0, W: 180, N: -90, S: 90 };
            return rotations[moveDir] ?? 0;
        }

        function rotateDirection(dir, rotationDeg) {
            const order = ['N', 'E', 'S', 'W'];
            const index = order.indexOf(dir);
            if (index === -1) return dir;
            const steps = ((rotationDeg / 90) % 4 + 4) % 4;
            return order[(index + steps) % 4];
        }

        function rotateExits(exits, rotationDeg) {
            return exits.map(exit => rotateDirection(exit, rotationDeg));
        }

        function randomRotation() {
            const rotations = [0, 90, 180, 270];
            return pick(rotations);
        }

        function normalizePngPath(path) {
            if (!path) return path;
            const normalized = path.replace(/\\/g, '/');
            const pngIndex = normalized.indexOf('png/');
            if (pngIndex >= 0) {
                return normalized.slice(pngIndex);
            }
            return normalized.split('/').pop();
        }

        function getPngSrc(path) {
            const normalized = normalizePngPath(path);
            return pngCache[normalized] || path;
        }

        function updatePngStatus() {
            const status = document.getElementById('pngStatus');
            if (!status) return;
            if (missingPngPaths.size === 0) {
                status.classList.add('hidden');
                return;
            }
            status.className = 'data-status warning';
            status.textContent = `Missing PNGs (${missingPngPaths.size}). Load the png folder if running from local files.`;
            status.classList.remove('hidden');
        }

        function getRoomByPosition(position) {
            if (!dungeonState || !dungeonState.map) return null;
            const key = coordKey(position.x, position.y);
            const roomId = dungeonState.map[key];
            return dungeonState.rooms.find(room => room.id === roomId) || null;
        }

        function getCurrentRoom() {
            if (!dungeonState) return null;
            return dungeonState.rooms.find(room => room.id === dungeonState.currentRoomId) || null;
        }

        function getAvailableExpansionDirections(position, exits) {
            return exits.filter(dir => {
                const vec = directionVectors[dir];
                const nextPos = { x: position.x + vec.x, y: position.y + vec.y };
                return !dungeonState.map[coordKey(nextPos.x, nextPos.y)];
            });
        }

        function getFrontierCount() {
            if (!dungeonState) return 0;
            let count = 0;
            dungeonState.rooms.forEach(room => {
                room.exits.forEach(exit => {
                    const vec = directionVectors[exit];
                    const nextPos = { x: room.position.x + vec.x, y: room.position.y + vec.y };
                    if (!dungeonState.map[coordKey(nextPos.x, nextPos.y)]) {
                        count += 1;
                    }
                });
            });
            return count;
        }

        function roomHasExit(room, direction) {
            if (!room) return false;
            return room.exits.includes(direction) || room.entryDir === direction;
        }

        function markDoorOpen(room, direction) {
            if (!room) return;
            if (!room.doors) {
                room.doors = {};
            }
            room.doors[direction] = { status: 'Open', bypass: null };
        }

        function getLinkedNeighborDirections(room) {
            if (!room) return [];
            return Object.keys(directionVectors).filter(dir => {
                if (!roomHasExit(room, dir)) {
                    return false;
                }
                const vec = directionVectors[dir];
                const neighborPos = { x: room.position.x + vec.x, y: room.position.y + vec.y };
                const neighbor = getRoomByPosition(neighborPos);
                return neighbor ? roomHasExit(neighbor, getOppositeDirection(dir)) : false;
            });
        }

        function getNeighborExitConstraints(position) {
            const requiredExits = new Set();
            const forbiddenExits = new Set();
            Object.keys(directionVectors).forEach(dir => {
                const vec = directionVectors[dir];
                const neighborPos = { x: position.x + vec.x, y: position.y + vec.y };
                const neighbor = getRoomByPosition(neighborPos);
                if (!neighbor) return;
                const oppositeDir = getOppositeDirection(dir);
                if (roomHasExit(neighbor, oppositeDir)) {
                    requiredExits.add(dir);
                } else {
                    forbiddenExits.add(dir);
                }
            });
            return { requiredExits, forbiddenExits };
        }

        function layoutMatchesConstraints(exits, constraints) {
            const exitSet = new Set(exits);
            for (const required of constraints.requiredExits) {
                if (!exitSet.has(required)) {
                    return false;
                }
            }
            for (const forbidden of constraints.forbiddenExits) {
                if (exitSet.has(forbidden)) {
                    return false;
                }
            }
            return true;
        }

        function applyExitConstraints(exits, constraints) {
            const adjusted = new Set(exits);
            constraints.forbiddenExits.forEach(dir => adjusted.delete(dir));
            constraints.requiredExits.forEach(dir => adjusted.add(dir));
            return Array.from(adjusted);
        }

        // ==================== LAYOUT SELECTION ====================
        function selectLayout({ isBossRoom, minExits, includeDeadEnds }) {
            const buckets = isBossRoom
                ? ["Rooms", "Halls"]
                : ["Rooms", "Halls", ...(includeDeadEnds ? ["Dead Ends"] : [])];

            const bucketWeights = isBossRoom
                ? { "Rooms": 70, "Halls": 30 }
                : {
                    "Rooms": 50,
                    "Halls": 35,
                    ...(includeDeadEnds ? { "Dead Ends": 15 } : {})
                };

            const bucket = weightedPick(bucketWeights);
            const available = gameData.layouts[bucket].filter(id => {
                if (usedLayouts[bucket].includes(id)) return false;
                const exits = getExitsForLayout(id);
                return exits.length >= minExits;
            });

            if (available.length === 0) {
                usedLayouts[bucket] = [];
                return selectLayout({ isBossRoom, minExits });
            }

            const layoutId = pick(available);
            usedLayouts[bucket].push(layoutId);

            return { bucket, layoutId };
        }

        // ==================== DESCRIPTION GENERATION ====================
        function generateDescription() {
            const leadIn = pick(gameData.leadIns);
            const roomType = pick(gameData.roomTypes);
            const underfoot = pick(gameData.sensesUnderfoot);
            
            // Pick one other sense type
            const otherSenses = [gameData.sensesAir, gameData.sensesSound, gameData.sensesLight];
            const otherSense = pick(pick(otherSenses));
            
            const anchor = pick(gameData.anchorFeatures);
            const interaction = pick(gameData.interactions);
            const pressure = pick(gameData.pressures);
            const mitigation = pick(gameData.mitigations);
            
            const profile = gameData.difficultyProfiles[dungeonState.difficulty];
            const potency = weightedPick(profile.potencyWeights);
            
            return {
                text: `${leadIn} ${article(roomType)} ${roomType}; ${underfoot}, ${otherSense}. ${anchor} stands ${interaction}. ${pressure}, but ${article(potency)} ${potency} check could ${mitigation}.`,
                potency
            };
        }

        // ==================== DOOR GENERATION ====================
        function generateDoor(profile) {
            const status = pick(gameData.doorStatuses);

            if (status === "Open") {
                return { status, bypass: null };
            }

            const bypassInfo = gameData.doorBypassVerbs[status] || { verbs: ["overcome"] };
            const potency = weightedPick(profile.potencyWeights);
            const threshold = randInt(profile.baseThresholdRange.min, profile.baseThresholdRange.max);

            const door = {
                status,
                bypass: {
                    potency,
                    threshold,
                    verb: pick(bypassInfo.verbs)
                }
            };

            // Add trap damage for Trapped doors
            if (status === "Trapped") {
                door.trapDamage = randInt(profile.damageRange.min, profile.damageRange.max);
            }

            return door;
        }

        // ==================== THREAT GENERATION ====================
        function getAbilityDescription(abilityName) {
            // Look up the full ability description from the striveAbilities list
            const ability = gameData.striveAbilities.find(a => a.startsWith(abilityName + ':'));
            return ability || abilityName;
        }

        function generateThreats(isBoss) {
            const profile = gameData.difficultyProfiles[dungeonState.difficulty];
            const keywords = dungeonState.keywords || [{ name: "Enemy", abilities: [] }];

            if (isBoss) {
                // Boss uses the first keyword
                const keywordData = keywords[0];
                return [generateBossThreat(profile, keywordData.name, keywordData.abilities)];
            }

            const numTypes = randInt(profile.threatTypesRange.min, profile.threatTypesRange.max);
            if (numTypes === 0) return [];

            const threats = [];
            const usedTypes = [];
            let totalThreatCount = 0;
            const maxThreats = profile.maxThreatsPerRoom || 99;

            for (let i = 0; i < numTypes; i++) {
                if (totalThreatCount >= maxThreats) break;

                const availableTypes = gameData.typeWords.filter(t => !usedTypes.includes(t));
                if (availableTypes.length === 0) break;

                const type = pick(availableTypes);
                usedTypes.push(type);

                // Pick a random keyword for this threat
                const keywordData = pick(keywords);
                const keyword = keywordData.name;
                const keywordAbilities = keywordData.abilities;

                // Calculate quantity, respecting max threats limit
                const remainingSlots = maxThreats - totalThreatCount;
                const maxQuantity = Math.min(profile.quantityRange.max, remainingSlots);
                const quantity = randInt(profile.quantityRange.min, maxQuantity);
                totalThreatCount += quantity;
                const damage = randInt(profile.damageRange.min, profile.damageRange.max);
                const threshold = randInt(profile.baseThresholdRange.min, profile.baseThresholdRange.max);

                // Determine success tiers - Hard/Deadly may use weaker tiers for variety
                let successTiers = profile.successTiers;
                if (profile.successTiersWeak && Math.random() < 0.4) {
                    successTiers = profile.successTiersWeak;
                }

                const abilities = [];
                if (gameData.wordToAbility[type]) {
                    abilities.push(gameData.wordToAbility[type]);
                }
                if (keywordAbilities.length > 0 && Math.random() < profile.keywordAbilityChance) {
                    const abilityName = pick(keywordAbilities);
                    abilities.push(getAbilityDescription(abilityName));
                }

                // Get range for this type - pick randomly if array
                const typeRangeValue = gameData.typeRange[type] || "Melee";
                const range = Array.isArray(typeRangeValue) ? pick(typeRangeValue) : typeRangeValue;

                const threat = {
                    keyword,
                    type,
                    quantity,
                    damage,
                    threshold,
                    defeat: successTiers.defeat,
                    overwhelm: successTiers.overwhelm,
                    range,
                    abilities,
                    isBoss: false
                };

                threats.push(threat);
            }

            return threats;
        }

        function generateBossThreat(profile, keyword, keywordAbilities) {
            const type = pick(gameData.typeWords);
            const baseDamage = profile.damageRange.max;
            const damage = baseDamage + profile.bossDamageBonus;
            const threshold = profile.baseThresholdRange.max;

            const abilities = [];
            if (gameData.wordToAbility[type]) {
                abilities.push(gameData.wordToAbility[type]);
            }
            // Boss always gets a keyword ability if available
            if (keywordAbilities.length > 0) {
                const abilityName = pick(keywordAbilities);
                abilities.push(getAbilityDescription(abilityName));
            }
            abilities.push("Heedless: This threat has no Defeat Tier and must be Overwhelmed to be defeated.");

            // Boss range - typically melee (all) or ranged (2)
            const bossRange = Math.random() < 0.5 ? "Melee (All)" : "Ranged (2)";

            return {
                keyword,
                type,
                quantity: 1,
                damage,
                threshold,
                defeat: profile.successTiers.defeat + profile.bossDefeatBonus,
                overwhelm: profile.successTiers.overwhelm + profile.bossOverwhelmBonus,
                range: bossRange,
                abilities,
                isBoss: true
            };
        }

        // ==================== LOOT GENERATION ====================
        function rollLootRarity(hasEncounter, isBoss) {
            const baseWeights = LOOT_RARITY_WEIGHTS[dungeonState.difficulty] || LOOT_RARITY_WEIGHTS.Medium;
            const adjusted = adjustRarityWeights(baseWeights, hasEncounter, isBoss);
            return weightedPick(adjusted);
        }

        function pickMagicItem(rarity, potionChance) {
            const pool = LOOT_DATA.magic[rarity] || LOOT_DATA.magic.Common;
            const usePotion = pool.potions.length > 0 && Math.random() < potionChance;
            const name = usePotion ? pick(pool.potions) : pick(pool.items);
            return {
                name,
                category: "Magic",
                rarity
            };
        }

        function generateCoins(hasEncounter, isBoss) {
            const ranges = {
                Easy: { min: 10, max: 60 },
                Medium: { min: 25, max: 120 },
                Hard: { min: 60, max: 240 },
                Deadly: { min: 120, max: 400 }
            };
            const range = ranges[dungeonState.difficulty] || ranges.Medium;
            const multiplier = (hasEncounter ? 1.5 : 1) * (isBoss ? 2 : 1);
            const total = Math.max(1, Math.round(randInt(range.min, range.max) * multiplier));
            const gp = Math.floor(total / 50);
            const sp = Math.floor((total % 50) / 10);
            const cp = total % 10;
            return { total, gp, sp, cp };
        }

        function generateLoot(room) {
            const hasEncounter = room.threats && room.threats.length > 0;
            const isBoss = room.isBoss;
            const loot = { coins: null, items: [] };

            const coinChance = isBoss ? 1 : hasEncounter ? 0.85 : 0.55;
            if (Math.random() < coinChance) {
                loot.coins = generateCoins(hasEncounter, isBoss);
            }

            const mundaneCount = isBoss ? randInt(2, 3) : hasEncounter ? randInt(1, 2) : randInt(0, 1);
            for (let i = 0; i < mundaneCount; i++) {
                const pool = Math.random() < 0.55 ? LOOT_DATA.mundane.equipment : LOOT_DATA.mundane.supplies;
                loot.items.push({
                    name: pick(pool),
                    category: "Mundane"
                });
            }

            const trinketChance = isBoss ? 0.75 : hasEncounter ? 0.55 : 0.3;
            if (Math.random() < trinketChance) {
                loot.items.push({
                    name: pick(LOOT_DATA.mundane.trinkets),
                    category: "Trinket"
                });
            }
            const gemChance = isBoss ? 0.65 : hasEncounter ? 0.5 : 0.25;
            if (Math.random() < gemChance) {
                loot.items.push({
                    name: pick(LOOT_DATA.mundane.gemstones),
                    category: "Gemstone"
                });
            }

            const magicChance = isBoss ? 0.95 : hasEncounter ? 0.7 : 0.35;
            if (Math.random() < magicChance) {
                const magicCount = isBoss ? randInt(2, 3) : hasEncounter ? randInt(1, 2) : 1;
                const potionChance = isBoss ? 0.7 : hasEncounter ? 0.6 : 0.45;
                for (let i = 0; i < magicCount; i++) {
                    const rarity = rollLootRarity(hasEncounter, isBoss);
                    loot.items.push(pickMagicItem(rarity, potionChance));
                }
            }

            return loot;
        }

        function ensureRoomLoot(room) {
            if (!room.loot) {
                room.loot = generateLoot(room);
                return true;
            }
            return false;
        }

        function formatLootSummary(loot) {
            if (!loot) return "No notable loot";
            const parts = [];
            if (loot.coins) {
                parts.push(`Coins: ${formatCoins(loot.coins)}`);
            }
            if (loot.items && loot.items.length > 0) {
                const names = loot.items.map(item => item.name);
                const shown = names.slice(0, 3).join(', ');
                const extra = names.length > 3 ? ` +${names.length - 3} more` : '';
                parts.push(`Items: ${shown}${extra}`);
            }
            return parts.length > 0 ? parts.join(' • ') : "No notable loot";
        }

        // ==================== ROOM GENERATION ====================
        function generateRoom({ position, moveDir, fromRoom }) {
            const roomIndex = dungeonState.rooms.length + 1;
            const profile = gameData.difficultyProfiles[dungeonState.difficulty];
            const isEntrance = roomIndex === 1;
            const rotation = isEntrance
                ? randomRotation()
                : (moveDir ? getRotationForMove(moveDir) : 0);
            const remainingAfter = dungeonState.totalRooms - (dungeonState.rooms.length + 1);
            const frontierBefore = getFrontierCount();
            const usedExit = fromRoom && moveDir ? 1 : 0;
            const guaranteedFrontier = frontierBefore - usedExit;
            const minExits = isEntrance
                ? 1
                : (remainingAfter > 0 && guaranteedFrontier === 0 ? 1 : 0);
            const includeDeadEnds = !isEntrance && remainingAfter > 0 && guaranteedFrontier > 0;
            const neighborConstraints = getNeighborExitConstraints(position);

            let layoutSelection = null;
            let attempts = 0;
            while (!layoutSelection && attempts < 20) {
                if (isEntrance) {
                    const entranceIds = Object.keys(gameData.entranceLayouts || {});
                    const entranceId = pick(entranceIds);
                    const exits = gameData.entranceLayouts[entranceId] || [];
                    const mapExits = rotateExits(exits, rotation);
                    const availableExits = getAvailableExpansionDirections(position, mapExits);
                    if (remainingAfter === 0 || availableExits.length > 0) {
                        layoutSelection = {
                            bucket: "Entrance",
                            layoutId: entranceId,
                            exits,
                            mapExits
                        };
                    }
                } else {
                    const candidate = selectLayout({ isBossRoom: false, minExits, includeDeadEnds });
                    const exits = getExitsForLayout(candidate.layoutId);
                    const mapExits = rotateExits(exits, rotation);
                    if (!layoutMatchesConstraints(mapExits, neighborConstraints)) {
                        attempts += 1;
                        continue;
                    }
                    const availableExits = getAvailableExpansionDirections(position, mapExits);
                    const frontierAfter = guaranteedFrontier + availableExits.length;
                    if (remainingAfter === 0 || frontierAfter > 0) {
                        layoutSelection = { ...candidate, exits, mapExits };
                    }
                }
                attempts += 1;
            }

            if (!layoutSelection && !isEntrance) {
                const fallback = selectLayout({ isBossRoom: false, minExits: 0, includeDeadEnds: true });
                layoutSelection = {
                    ...fallback,
                    exits: getExitsForLayout(fallback.layoutId),
                    mapExits: rotateExits(getExitsForLayout(fallback.layoutId), rotation)
                };
            }

            if (!layoutSelection && isEntrance) {
                const entranceIds = Object.keys(gameData.entranceLayouts || {});
                const entranceId = entranceIds[0] || "ENT_E";
                const exits = gameData.entranceLayouts[entranceId] || [];
                layoutSelection = {
                    bucket: "Entrance",
                    layoutId: entranceId,
                    exits,
                    mapExits: rotateExits(exits, rotation)
                };
            }

            layoutSelection.mapExits = applyExitConstraints(layoutSelection.mapExits, neighborConstraints);
            const description = generateDescription();
            const doors = {};
            layoutSelection.mapExits.forEach(exit => {
                doors[exit] = generateDoor(profile);
            });

            const room = {
                id: `room_${Date.now()}_${roomIndex}`,
                index: roomIndex,
                isBoss: roomIndex === dungeonState.totalRooms,
                bucket: layoutSelection.bucket,
                layoutId: layoutSelection.layoutId,
                pngPath: `png/${layoutSelection.bucket.toLowerCase().replace(' ', '-')}/${layoutSelection.layoutId}.png`,
                exits: layoutSelection.mapExits,
                baseExits: layoutSelection.exits,
                doors,
                rotation,
                position,
                entryDir: moveDir ? getOppositeDirection(moveDir) : null,
                description: description.text,
                descriptionPotency: description.potency,
                threats: generateThreats(roomIndex === dungeonState.totalRooms),
                loot: null,
                timestamp: Date.now()
            };

            room.loot = generateLoot(room);

            dungeonState.rooms.push(room);
            dungeonState.map[coordKey(position.x, position.y)] = room.id;
            saveDungeonState();

            return room;
        }

        function assignBossRoom() {
            if (!dungeonState || dungeonState.rooms.length === 0) return;
            const bossRoom = dungeonState.rooms.find(room => room.index === dungeonState.totalRooms);
            dungeonState.rooms.forEach(room => {
                const shouldBeBoss = bossRoom ? room.id === bossRoom.id : false;
                const wasBoss = room.isBoss;
                if (shouldBeBoss && !room.isBoss) {
                    room.threats = generateThreats(true);
                }
                if (!shouldBeBoss && room.isBoss) {
                    room.threats = generateThreats(false);
                }
                room.isBoss = shouldBeBoss;
                if (wasBoss !== room.isBoss) {
                    room.loot = generateLoot(room);
                }
            });
            dungeonState.bossRoomId = bossRoom ? bossRoom.id : null;
            saveDungeonState();
        }

        // ==================== RENDERING ====================
        function renderRoom(room) {
            document.getElementById('emptyState').classList.add('hidden');
            document.getElementById('roomContent').classList.remove('hidden');

            const lootUpdated = ensureRoomLoot(room);
            if (lootUpdated) {
                saveDungeonState();
            }
            
            const displayExits = [...room.exits];
            if (room.entryDir && !displayExits.includes(room.entryDir)) {
                displayExits.push(room.entryDir);
            }
            getLinkedNeighborDirections(room).forEach(dir => {
                if (!displayExits.includes(dir)) {
                    displayExits.push(dir);
                }
            });

            let exitsHtml = '';
            if (displayExits.length === 0) {
                exitsHtml = '<div class="no-threats">No exits — Dead End. Retrace your steps.</div>';
            } else {
                exitsHtml = '<div class="exit-list">';
                const dirNames = { N: 'North', E: 'East', S: 'South', W: 'West' };
                displayExits.forEach(exit => {
                    const isEntry = exit === room.entryDir;
                    const baseDoor = room.doors[exit] || { status: 'Open' };
                    const door = isEntry ? { status: 'Open' } : baseDoor;
                    const statusClass = door.status === 'Open' ? 'open' : 'blocked';
                    let bypassHtml = '';
                    if (door.bypass) {
                        const trapDamageHtml = door.trapDamage
                            ? `<div class="trap-damage">Trap Damage: ${door.trapDamage}d6</div>`
                            : '';
                        bypassHtml = `<div class="bypass-info">
                            Bypass: <span class="potency-${door.bypass.potency.toLowerCase()}">${door.bypass.potency}</span>
                            check to ${door.bypass.verb}, Threshold +${door.bypass.threshold}
                            ${trapDamageHtml}
                        </div>`;
                    }
                    const vec = directionVectors[exit];
                    const targetPos = { x: room.position.x + vec.x, y: room.position.y + vec.y };
                    const targetRoom = getRoomByPosition(targetPos);
                    const oppositeDir = getOppositeDirection(exit);
                    const canLink = targetRoom
                        ? roomHasExit(room, exit) && roomHasExit(targetRoom, oppositeDir)
                        : true;
                    const canCreate = (!!targetRoom && canLink) || (!targetRoom && dungeonState.rooms.length < dungeonState.totalRooms);
                    const buttonLabel = targetRoom ? 'Return' : 'Go this way';
                    exitsHtml += `
                        <div class="exit-item">
                            <span class="exit-direction">${dirNames[exit]}</span>
                            <span class="exit-status ${statusClass}">${door.status}</span>
                            <div class="exit-actions">
                                <button class="exit-action" data-dir="${exit}" ${canCreate ? '' : 'disabled'}>${buttonLabel}</button>
                            </div>
                            ${bypassHtml}
                        </div>
                    `;
                });
                exitsHtml += '</div>';
            }
            
            let threatsHtml = '';
            if (room.threats.length === 0) {
                threatsHtml = '<div class="no-threats">The room appears empty of immediate threats.</div>';
            } else {
                threatsHtml = '<div class="threat-list">';
                room.threats.forEach(threat => {
                    const bossClass = threat.isBoss ? 'boss' : '';
                    const abilitiesHtml = threat.abilities.length > 0
                        ? threat.abilities.map(a => `<div class="ability">• <span class="ability-name">${a}</span></div>`).join('')
                        : '<div class="ability">—</div>';

                    threatsHtml += `
                        <div class="threat-block ${bossClass}">
                            <div class="threat-header">
                                ${threat.isBoss ? '👑 BOSS: ' : ''}${threat.keyword} ${threat.type} x${threat.quantity}
                            </div>
                            <div class="threat-stats">
                                <div class="threat-stat"><span class="stat-label">Damage:</span> ${threat.damage}d6</div>
                                <div class="threat-stat"><span class="stat-label">Threshold:</span> +${threat.threshold}</div>
                                <div class="threat-stat"><span class="stat-label">Defeat/Overwhelm:</span> ${threat.defeat}/${threat.overwhelm}</div>
                                <div class="threat-stat"><span class="stat-label">Range:</span> ${threat.range || 'Melee'}</div>
                            </div>
                            <div class="threat-abilities">
                                <div class="ability" style="color: var(--text-muted); margin-bottom: 0.25rem;">Abilities:</div>
                                ${abilitiesHtml}
                            </div>
                        </div>
                    `;
                });
                threatsHtml += '</div>';
            }

            const loot = room.loot;
            let lootHtml = '';
            if (!loot || (!loot.coins && (!loot.items || loot.items.length === 0))) {
                lootHtml = '<div class="no-threats">No notable loot stands out at the moment.</div>';
            } else {
                const magicItems = (loot.items || []).filter(item => item.category === 'Magic');
                const mundaneItems = (loot.items || []).filter(item => item.category === 'Mundane');
                const curios = (loot.items || []).filter(item => ['Trinket', 'Gemstone'].includes(item.category));

                lootHtml = '<div class="loot-list">';
                if (loot.coins) {
                    lootHtml += `
                        <div class="loot-block">
                            <h4>Coins</h4>
                            <div class="loot-items">
                                <div class="loot-item">${formatCoins(loot.coins)}</div>
                            </div>
                        </div>
                    `;
                }
                if (magicItems.length > 0) {
                    lootHtml += `
                        <div class="loot-block">
                            <h4>Magic Items</h4>
                            <div class="loot-items">
                                ${magicItems.map(item => `
                                    <div class="loot-item">
                                        <span class="loot-tag ${item.rarity.toLowerCase()}">${item.rarity}</span>
                                        <span>${item.name}</span>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    `;
                }
                if (mundaneItems.length > 0) {
                    lootHtml += `
                        <div class="loot-block">
                            <h4>Supplies & Gear</h4>
                            <div class="loot-items">
                                ${mundaneItems.map(item => `<div class="loot-item">${item.name}</div>`).join('')}
                            </div>
                        </div>
                    `;
                }
                if (curios.length > 0) {
                    lootHtml += `
                        <div class="loot-block">
                            <h4>Trinkets & Gems</h4>
                            <div class="loot-items">
                                ${curios.map(item => `<div class="loot-item">${item.name}</div>`).join('')}
                            </div>
                        </div>
                    `;
                }
                lootHtml += '</div>';
            }
            
            document.getElementById('roomContent').innerHTML = `
                <div class="room-header">
                    <span class="room-number">Room ${room.index} of ${dungeonState.totalRooms}</span>
                    ${room.isBoss ? '<span class="room-badge">BOSS ROOM</span>' : ''}
                </div>
                <div class="room-body">
                    <div class="room-meta">
                        <div class="meta-item">
                            <span class="meta-label">Layout Type</span>
                            <span class="meta-value">${room.bucket}</span>
                        </div>
                        <div class="meta-item">
                            <span class="meta-label">Layout ID</span>
                            <span class="meta-value">${room.layoutId}</span>
                        </div>
                        <div class="meta-item">
                            <span class="meta-label">PNG Path</span>
                            <span class="meta-value">${room.pngPath}</span>
                        </div>
                        <div class="meta-item">
                            <span class="meta-label">Grid Position</span>
                            <span class="meta-value">(${room.position.x}, ${room.position.y})</span>
                        </div>
                        <div class="meta-item">
                            <span class="meta-label">Exits</span>
                            <span class="meta-value">${room.exits.length > 0 ? room.exits.join(', ') : 'None'}</span>
                        </div>
                    </div>
                    
                    <div class="room-description">${room.description}</div>
                    
                    <div class="exits">
                        <div class="section-title">Exits & Doors</div>
                        ${exitsHtml}
                    </div>
                    
                    <div class="threats">
                        <div class="section-title">Threats</div>
                        ${threatsHtml}
                    </div>

                    <div class="loot">
                        <div class="section-title">Loot</div>
                        ${lootHtml}
                    </div>
                </div>
            `;
            
            document.querySelectorAll('.exit-action').forEach(button => {
                button.addEventListener('click', () => {
                    const direction = button.dataset.dir;
                    handleExitMove(direction);
                });
            });
        }

        function renderMap() {
            const mapGrid = document.getElementById('mapGrid');
            const mapRooms = document.getElementById('mapRooms');
            const mapEmpty = document.getElementById('mapEmpty');

            if (!dungeonState || dungeonState.rooms.length === 0) {
                mapGrid.classList.add('hidden');
                mapEmpty.classList.remove('hidden');
                return;
            }

            mapGrid.classList.remove('hidden');
            mapEmpty.classList.add('hidden');

            const positions = dungeonState.rooms.map(room => room.position);
            const minX = Math.min(...positions.map(pos => pos.x));
            const maxX = Math.max(...positions.map(pos => pos.x));
            const minY = Math.min(...positions.map(pos => pos.y));
            const maxY = Math.max(...positions.map(pos => pos.y));

            const roomSize = 140;
            const padding = 70;
            const width = (maxX - minX + 1) * roomSize + padding * 2;
            const height = (maxY - minY + 1) * roomSize + padding * 2;

            mapGrid.style.setProperty('--room-size', `${roomSize}px`);
            mapGrid.style.width = `${Math.max(width, 240)}px`;
            mapGrid.style.height = `${Math.max(height, 240)}px`;
            mapRooms.style.width = `${Math.max(width, 240)}px`;
            mapRooms.style.height = `${Math.max(height, 240)}px`;

            mapRooms.innerHTML = '';
            dungeonState.rooms.forEach(room => {
                const offsetX = (room.position.x - minX) * roomSize + padding;
                const offsetY = (room.position.y - minY) * roomSize + padding;
                const roomDiv = document.createElement('div');
                const isCurrent = room.id === dungeonState.currentRoomId;
                const isStart = room.position.x === 0 && room.position.y === 0;
                const isBoss = room.id === dungeonState.bossRoomId;

                roomDiv.className = `map-room${isCurrent ? ' current' : ''}${isStart ? ' start' : ''}${isBoss ? ' boss' : ''}`;
                roomDiv.style.left = `${offsetX}px`;
                roomDiv.style.top = `${offsetY}px`;

                const img = document.createElement('img');
                img.src = getPngSrc(room.pngPath);
                img.alt = `Room ${room.index}`;
                img.style.transform = `rotate(${room.rotation}deg)`;
                img.addEventListener('error', () => {
                    const normalized = normalizePngPath(room.pngPath);
                    if (!missingPngPaths.has(normalized)) {
                        missingPngPaths.add(normalized);
                        updatePngStatus();
                    }
                });

                const label = document.createElement('div');
                label.className = 'map-room-label';
                label.innerHTML = `${room.isBoss ? '👑 ' : ''}<span>Room ${room.index}</span>`;

                roomDiv.appendChild(img);
                roomDiv.appendChild(label);
                mapRooms.appendChild(roomDiv);
            });
        }

        function handleExitMove(direction) {
            if (!dungeonState) return;
            const currentRoom = getCurrentRoom();
            if (!currentRoom) return;
            const vec = directionVectors[direction];
            const nextPos = { x: currentRoom.position.x + vec.x, y: currentRoom.position.y + vec.y };
            const existingRoom = getRoomByPosition(nextPos);

            if (existingRoom) {
                const oppositeDir = getOppositeDirection(direction);
                if (!roomHasExit(currentRoom, direction) || !roomHasExit(existingRoom, oppositeDir)) {
                    return;
                }
                markDoorOpen(currentRoom, direction);
                markDoorOpen(existingRoom, oppositeDir);
                dungeonState.currentRoomId = existingRoom.id;
                renderRoom(existingRoom);
                renderMap();
                updateButtons();
                saveDungeonState();
                return;
            }

            if (dungeonState.rooms.length >= dungeonState.totalRooms) {
                return;
            }

            const newRoom = generateRoom({ position: nextPos, moveDir: direction, fromRoom: currentRoom });
            dungeonState.currentRoomId = newRoom.id;
            if (newRoom.isBoss) {
                dungeonState.bossRoomId = newRoom.id;
            }

            renderRoom(newRoom);
            renderMap();
            updateButtons();
        }

        function updateButtons() {
            const hasState = dungeonState !== null;
            document.getElementById('exportBtn').disabled = !hasState || dungeonState.rooms.length === 0;
        }

        // ==================== PERSISTENCE ====================
        function saveDungeonState() {
            localStorage.setItem('striveDungeon', JSON.stringify(dungeonState));
            localStorage.setItem('striveUsedLayouts', JSON.stringify(usedLayouts));
        }

        function loadDungeonState() {
            const saved = localStorage.getItem('striveDungeon');
            const savedLayouts = localStorage.getItem('striveUsedLayouts');
            
            if (saved) {
                dungeonState = JSON.parse(saved);
                usedLayouts = savedLayouts ? JSON.parse(savedLayouts) : { Rooms: [], Halls: [], "Dead Ends": [] };

                if (!dungeonState.map || dungeonState.rooms.some(room => !room.position)) {
                    localStorage.removeItem('striveDungeon');
                    localStorage.removeItem('striveUsedLayouts');
                    dungeonState = null;
                    usedLayouts = { Rooms: [], Halls: [], "Dead Ends": [] };
                    return;
                }

                if (!dungeonState.currentRoomId && dungeonState.rooms.length > 0) {
                    dungeonState.currentRoomId = dungeonState.rooms[dungeonState.rooms.length - 1].id;
                }
                
                if (dungeonState.rooms.length > 0) {
                    if (!dungeonState.bossRoomId) {
                        assignBossRoom();
                    }
                    renderRoom(getCurrentRoom());
                }
                renderMap();
                updateButtons();
                
                // Restore UI values
                document.getElementById('difficulty').value = dungeonState.difficulty;
                document.getElementById('dungeonLength').value = dungeonState.totalRooms;

                // Restore keywords and abilities
                if (dungeonState.keywords && dungeonState.keywords.length > 0) {
                    const kw1 = dungeonState.keywords[0];
                    document.getElementById('threatKeyword1').value = kw1.name || '';
                    if (kw1.abilities) {
                        if (kw1.abilities[0]) document.getElementById('keywordAbility1_1').value = kw1.abilities[0];
                        if (kw1.abilities[1]) document.getElementById('keywordAbility1_2').value = kw1.abilities[1];
                        if (kw1.abilities[2]) document.getElementById('keywordAbility1_3').value = kw1.abilities[2];
                    }

                    if (dungeonState.keywords.length > 1) {
                        const kw2 = dungeonState.keywords[1];
                        document.getElementById('threatKeyword2').value = kw2.name || '';
                        if (kw2.abilities) {
                            if (kw2.abilities[0]) document.getElementById('keywordAbility2_1').value = kw2.abilities[0];
                            if (kw2.abilities[1]) document.getElementById('keywordAbility2_2').value = kw2.abilities[1];
                            if (kw2.abilities[2]) document.getElementById('keywordAbility2_3').value = kw2.abilities[2];
                        }
                    }
                }
            }
        }

        // ==================== INITIALIZATION ====================
        function populateAbilityDatalist() {
            const datalist = document.getElementById('abilityList');
            datalist.innerHTML = '';
            gameData.striveAbilities.forEach(ability => {
                const option = document.createElement('option');
                // Extract just the ability name for the dropdown value
                const abilityName = ability.split(':')[0].trim();
                option.value = abilityName;
                option.textContent = ability;
                datalist.appendChild(option);
            });
        }

        // Populate datalist on page load
        populateAbilityDatalist();

        // ==================== EVENT HANDLERS ====================
        document.getElementById('startBtn').addEventListener('click', () => {
            const difficulty = document.getElementById('difficulty').value;
            const totalRooms = parseInt(document.getElementById('dungeonLength').value) || 10;

            // Get keyword 1 and its abilities
            const keyword1 = document.getElementById('threatKeyword1').value.trim() || "Enemy";
            const keyword1Abilities = [
                document.getElementById('keywordAbility1_1').value.trim(),
                document.getElementById('keywordAbility1_2').value.trim(),
                document.getElementById('keywordAbility1_3').value.trim()
            ].filter(a => a);

            // Get keyword 2 and its abilities (optional)
            const keyword2 = document.getElementById('threatKeyword2').value.trim();
            const keyword2Abilities = [
                document.getElementById('keywordAbility2_1').value.trim(),
                document.getElementById('keywordAbility2_2').value.trim(),
                document.getElementById('keywordAbility2_3').value.trim()
            ].filter(a => a);

            // Reset state
            usedLayouts = { Rooms: [], Halls: [], "Dead Ends": [] };
            dungeonState = {
                difficulty,
                totalRooms: Math.max(6, Math.min(30, totalRooms)),
                keywords: [
                    { name: keyword1, abilities: keyword1Abilities },
                    ...(keyword2 ? [{ name: keyword2, abilities: keyword2Abilities }] : [])
                ],
                rooms: [],
                map: {},
                currentRoomId: null,
                bossRoomId: null,
                startedAt: Date.now()
            };

            // Generate first room
            const room = generateRoom({ position: { x: 0, y: 0 }, moveDir: null, fromRoom: null });
            dungeonState.currentRoomId = room.id;
            if (room.isBoss) {
                dungeonState.bossRoomId = room.id;
            }
            renderRoom(room);
            renderMap();
            updateButtons();
        });

        document.getElementById('exportBtn').addEventListener('click', () => {
            if (!dungeonState) return;
            
            const exportData = {
                ...dungeonState,
                exportedAt: Date.now(),
                gameData: gameData
            };
            
            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `dungeon_${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
        });

        document.getElementById('dataFile').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;
            
            try {
                const text = await file.text();
                const data = JSON.parse(text);
                
                // Validate required fields
                const required = ['roomTypes', 'leadIns', 'doorStatuses', 'typeWords', 'difficultyProfiles'];
                const missing = required.filter(key => !data[key]);
                
                if (missing.length > 0) {
                    throw new Error(`Missing required fields: ${missing.join(', ')}`);
                }
                
                // Merge with defaults (so partial files work)
                gameData = { ...DEFAULT_DATA, ...data };
                
                document.getElementById('dataStatus').textContent = `Loaded: ${file.name}`;
                document.getElementById('dataStatus').className = 'data-status loaded';
                document.getElementById('errorDisplay').classList.add('hidden');
                
            } catch (err) {
                document.getElementById('errorDisplay').textContent = `Error loading file: ${err.message}`;
                document.getElementById('errorDisplay').classList.remove('hidden');
                gameData = JSON.parse(JSON.stringify(DEFAULT_DATA));
            }
        });

        document.getElementById('pngFolder').addEventListener('change', (e) => {
            const files = Array.from(e.target.files || []);
            if (files.length === 0) return;
            files.forEach(file => {
                const key = normalizePngPath(file.webkitRelativePath || file.name);
                pngCache[key] = URL.createObjectURL(file);
                missingPngPaths.delete(key);
            });
            updatePngStatus();
            renderMap();
        });

        // ==================== INIT ====================
        loadDungeonState();
    </script>
</body>
</html>
