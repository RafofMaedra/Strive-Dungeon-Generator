<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Strive Dungeon Generator</title>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Crimson+Text:ital,wght@0,400;0,600;1,400&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-dark: #0d0d0f;
            --bg-card: #16161a;
            --bg-card-hover: #1c1c22;
            --border: #2a2a35;
            --text-primary: #e8e6e3;
            --text-muted: #8b8680;
            --accent-gold: #c9a227;
            --accent-gold-dim: #8b7119;
            --accent-red: #8b2635;
            --accent-green: #2d5a27;
            --accent-blue: #1e3a5f;
            --danger: #6b1e1e;
            --font-display: 'Cinzel', serif;
            --font-body: 'Crimson Text', serif;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-body);
            background: var(--bg-dark);
            color: var(--text-primary);
            min-height: 100vh;
            line-height: 1.6;
            background-image: 
                radial-gradient(ellipse at 20% 0%, rgba(201, 162, 39, 0.03) 0%, transparent 50%),
                radial-gradient(ellipse at 80% 100%, rgba(139, 38, 53, 0.03) 0%, transparent 50%);
        }

        .container {
            max-width: 2000px;
            width: min(2000px, 96vw);
            margin: 0 auto;
            padding: 2rem;
        }

        header {
            text-align: center;
            margin-bottom: 3rem;
            padding: 2rem 0;
            border-bottom: 1px solid var(--border);
        }

        h1 {
            font-family: var(--font-display);
            font-size: 2.5rem;
            color: var(--accent-gold);
            letter-spacing: 0.15em;
            text-transform: uppercase;
            margin-bottom: 0.5rem;
            text-shadow: 0 0 40px rgba(201, 162, 39, 0.3);
        }

        .subtitle {
            color: var(--text-muted);
            font-style: italic;
            font-size: 1.1rem;
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1.5rem;
            margin-bottom: 1.5rem;
            padding: 1.5rem;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 4px;
        }

        .setup-panel {
            margin-bottom: 2rem;
            border: 1px solid var(--border);
            border-radius: 4px;
            background: var(--bg-card);
        }

        .setup-panel summary {
            cursor: pointer;
            padding: 1rem 1.5rem;
            font-family: var(--font-display);
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 0.15em;
            color: var(--accent-gold);
            list-style: none;
        }

        .setup-panel summary::-webkit-details-marker {
            display: none;
        }

        .setup-panel[open] summary {
            border-bottom: 1px solid var(--border);
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .control-group.full-width {
            grid-column: 1 / -1;
        }

        label {
            font-family: var(--font-display);
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--text-muted);
        }

        input, select {
            background: var(--bg-dark);
            border: 1px solid var(--border);
            color: var(--text-primary);
            padding: 0.75rem 1rem;
            font-family: var(--font-body);
            font-size: 1rem;
            border-radius: 2px;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        input:focus, select:focus {
            outline: none;
            border-color: var(--accent-gold-dim);
            box-shadow: 0 0 0 2px rgba(201, 162, 39, 0.1);
        }

        input[type="file"] {
            padding: 0.5rem;
        }

        .keyword-group {
            margin-bottom: 0.5rem;
        }

        .keyword-row {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        .keyword-input {
            flex: 0 0 120px;
            min-width: 100px;
        }

        .ability-input {
            flex: 1;
            min-width: 140px;
        }

        .buttons {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            margin-bottom: 2rem;
        }

        .threat-filter-row {
            display: flex;
            gap: 1rem;
            align-items: center;
            flex-wrap: wrap;
        }

        .helper-text {
            color: var(--text-muted);
            font-size: 0.9rem;
        }

        .filter-row {
            display: flex;
            gap: 1rem;
            align-items: center;
            flex-wrap: wrap;
        }

        button {
            font-family: var(--font-display);
            font-size: 0.8rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            padding: 1rem 1.5rem;
            border: 1px solid var(--border);
            background: var(--bg-card);
            color: var(--text-primary);
            cursor: pointer;
            transition: all 0.2s;
            border-radius: 2px;
        }

        button:hover {
            background: var(--bg-card-hover);
            border-color: var(--accent-gold-dim);
        }

        button.primary {
            background: linear-gradient(135deg, var(--accent-gold-dim), var(--accent-gold));
            color: var(--bg-dark);
            border-color: var(--accent-gold);
            font-weight: 700;
        }

        button.primary:hover {
            box-shadow: 0 0 20px rgba(201, 162, 39, 0.3);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .modal {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.65);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 1.5rem;
            z-index: 100;
        }

        .modal.hidden {
            display: none;
        }

        .modal-card {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 4px;
            width: min(680px, 92vw);
            max-height: 80vh;
            display: flex;
            flex-direction: column;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.4);
        }

        .modal-header,
        .modal-footer {
            padding: 1rem 1.5rem;
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 1rem;
        }

        .modal-footer {
            border-bottom: none;
            border-top: 1px solid var(--border);
            justify-content: flex-end;
        }

        .modal-body {
            padding: 1rem 1.5rem 1.5rem;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .modal-title {
            font-family: var(--font-display);
            letter-spacing: 0.12em;
            text-transform: uppercase;
            color: var(--accent-gold);
            font-size: 0.9rem;
        }

        .threat-type-list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
            gap: 0.5rem 1rem;
        }

        .threat-type-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.95rem;
        }

        /* Tooltip styles */
        .tooltip-container {
            position: relative;
            display: inline-flex;
            align-items: center;
        }

        .tooltip-icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 16px;
            height: 16px;
            font-size: 0.7rem;
            font-weight: bold;
            color: var(--text-muted);
            background: rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            cursor: help;
            margin-left: 0.25rem;
            flex-shrink: 0;
        }

        .tooltip-icon:hover {
            color: var(--accent-gold);
            background: rgba(255, 255, 255, 0.2);
        }

        .tooltip-text {
            visibility: hidden;
            opacity: 0;
            position: fixed;
            z-index: 10000;
            background: var(--bg-card);
            color: var(--text-primary);
            padding: 0.75rem 1rem;
            border-radius: 6px;
            font-size: 0.85rem;
            line-height: 1.4;
            width: 280px;
            max-width: 90vw;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            border: 1px solid var(--border-color);
            transition: opacity 0.2s ease, visibility 0.2s ease;
            pointer-events: none;
        }

        .tooltip-container:hover .tooltip-text {
            visibility: visible;
            opacity: 1;
        }

        .tooltip-ability-name {
            color: var(--accent-gold);
            font-weight: 600;
            display: block;
            margin-bottom: 0.25rem;
        }

        .main-content {
            display: grid;
            grid-template-columns: minmax(550px, 1.3fr) minmax(520px, 1fr);
            gap: 2rem;
        }

        @media (max-width: 900px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }

        .current-room {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 4px;
            overflow: hidden;
        }

        .room-header {
            background: linear-gradient(90deg, var(--accent-gold-dim), transparent);
            padding: 1rem 1.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .room-number {
            font-family: var(--font-display);
            font-size: 1.2rem;
            color: var(--accent-gold);
        }

        .room-badge {
            font-family: var(--font-display);
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.15em;
            padding: 0.4rem 0.8rem;
            background: var(--danger);
            border-radius: 2px;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .room-body {
            padding: 1.5rem;
        }

        .room-meta {
            display: flex;
            gap: 1.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--border);
            flex-wrap: wrap;
        }

        .meta-item {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        .meta-label {
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--text-muted);
        }

        .meta-value {
            font-size: 0.95rem;
            color: var(--accent-gold);
        }

        .room-description {
            font-size: 1.15rem;
            line-height: 1.8;
            margin-bottom: 1.5rem;
            padding: 1rem;
            background: rgba(0,0,0,0.3);
            border-left: 3px solid var(--accent-gold-dim);
            font-style: italic;
        }

        .section-title {
            font-family: var(--font-display);
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 0.15em;
            color: var(--accent-gold);
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border);
        }

        .exits {
            margin-bottom: 1.5rem;
        }

        .exit-list {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .exit-item {
            padding: 0.75rem 1rem;
            background: rgba(0,0,0,0.2);
            border-radius: 2px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        .exit-direction {
            font-family: var(--font-display);
            font-weight: 700;
            min-width: 60px;
        }

        .exit-status {
            flex: 1;
        }

        .exit-status.open { color: var(--accent-green); }
        .exit-status.blocked { color: var(--accent-red); }

        .bypass-info {
            font-size: 0.9rem;
            color: var(--text-muted);
            width: 100%;
            margin-top: 0.25rem;
            padding-left: 70px;
        }

        .trap-damage {
            color: var(--accent-red);
            font-weight: bold;
            margin-top: 0.25rem;
        }

        /* Dice Roller */
        .dice-roller {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: 1rem;
            margin-bottom: 1.5rem;
            display: flex;
            align-items: center;
            gap: 1.5rem;
            flex-wrap: wrap;
        }

        .dice-roller-title {
            font-family: var(--font-display);
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--accent-gold);
        }

        .dice-section {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .dice-container {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        .dice-control-btn {
            width: 28px;
            height: 28px;
            border-radius: 4px;
            background: var(--bg-dark);
            border: 1px solid var(--border);
            color: var(--text-muted);
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .dice-control-btn:hover:not(:disabled) {
            border-color: var(--accent-gold);
            color: var(--accent-gold);
        }

        .dice-control-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .die {
            width: 48px;
            height: 48px;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: var(--font-display);
            font-size: 1.5rem;
            font-weight: bold;
            color: #fff;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            box-shadow: 2px 2px 4px rgba(0,0,0,0.3), inset 1px 1px 2px rgba(255,255,255,0.2);
            transition: transform 0.1s;
            cursor: pointer;
            user-select: none;
        }

        .die:hover {
            transform: scale(1.05);
        }

        .die.rolling {
            animation: diceRoll 0.4s ease-out;
        }

        @keyframes diceRoll {
            0% { transform: rotate(0deg) scale(1); }
            25% { transform: rotate(90deg) scale(1.1); }
            50% { transform: rotate(180deg) scale(1); }
            75% { transform: rotate(270deg) scale(1.1); }
            100% { transform: rotate(360deg) scale(1); }
        }

        .die.red {
            background: linear-gradient(135deg, #c0392b, #8b2635);
            border: 2px solid #e74c3c;
        }

        .die.blue {
            background: linear-gradient(135deg, #2980b9, #1e3a5f);
            border: 2px solid #3498db;
        }

        .die.green {
            background: linear-gradient(135deg, #27ae60, #2d5a27);
            border: 2px solid #2ecc71;
        }

        .die.black {
            background: linear-gradient(135deg, #2c2c2c, #1a1a1a);
            border: 2px solid #444;
        }

        .die.purple {
            background: linear-gradient(135deg, #8e44ad, #5b2c6f);
            border: 2px solid #9b59b6;
        }

        .die-value {
            min-width: 20px;
            text-align: center;
        }

        .roll-button, .rest-button {
            font-family: var(--font-display);
            font-size: 0.8rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            padding: 0.75rem 1.5rem;
            background: linear-gradient(135deg, var(--accent-gold), var(--accent-gold-dim));
            border: 1px solid var(--accent-gold);
            color: var(--bg-dark);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .roll-button:hover, .rest-button:hover {
            background: var(--accent-gold);
            box-shadow: 0 0 10px rgba(201, 162, 39, 0.4);
        }

        .dice-actions {
            display: flex;
            gap: 0.75rem;
            align-items: center;
        }

        /* Rest Modal */
        .rest-time-selector {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .rest-time-row {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .rest-time-label {
            font-size: 0.9rem;
            color: var(--text-muted);
            min-width: 80px;
        }

        .rest-time-input {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .rest-time-input input {
            width: 60px;
            padding: 0.5rem;
            background: var(--bg-dark);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text-primary);
            font-size: 1rem;
            text-align: center;
        }

        .rest-time-input span {
            color: var(--text-muted);
            font-size: 0.85rem;
        }

        .rest-quarters {
            display: flex;
            gap: 0.25rem;
            margin-left: 1rem;
        }

        .rest-quarter-btn {
            width: 36px;
            height: 36px;
            border-radius: 4px;
            background: var(--bg-dark);
            border: 1px solid var(--border);
            color: var(--text-muted);
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .rest-quarter-btn:hover {
            border-color: var(--accent-gold);
            color: var(--accent-gold);
        }

        .rest-quarter-btn.selected {
            background: var(--accent-gold);
            border-color: var(--accent-gold);
            color: var(--bg-dark);
        }

        .rest-total {
            font-family: var(--font-display);
            font-size: 1.1rem;
            color: var(--accent-gold);
            padding: 0.75rem;
            background: rgba(201, 162, 39, 0.1);
            border-radius: 4px;
            text-align: center;
        }

        .rest-warning {
            font-size: 0.85rem;
            color: var(--text-muted);
            font-style: italic;
        }

        .rest-result {
            padding: 1rem;
            border-radius: 4px;
            margin-top: 1rem;
        }

        .rest-result.success {
            background: rgba(39, 174, 96, 0.15);
            border: 1px solid rgba(39, 174, 96, 0.4);
        }

        .rest-result.interrupted {
            background: rgba(192, 57, 43, 0.15);
            border: 1px solid rgba(192, 57, 43, 0.4);
        }

        .rest-result-title {
            font-family: var(--font-display);
            font-size: 1rem;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            margin-bottom: 0.5rem;
        }

        .rest-result.success .rest-result-title {
            color: var(--accent-green);
        }

        .rest-result.interrupted .rest-result-title {
            color: var(--accent-red);
        }

        .rest-result-detail {
            font-size: 0.9rem;
            color: var(--text-primary);
        }

        .rest-recovery {
            margin-top: 0.5rem;
            padding: 0.5rem;
            background: rgba(0,0,0,0.2);
            border-radius: 4px;
            font-size: 0.85rem;
        }

        .threats {
            margin-bottom: 1rem;
        }

        .hidden-section {
            margin-bottom: 1rem;
        }

        .hidden-list {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        .hidden-tier {
            position: relative;
            flex: 1 1 240px;
            min-width: 220px;
            height: var(--hidden-tile-height, 200px);
        }

        .hidden-tier.revealed .hidden-cover {
            opacity: 0;
            pointer-events: none;
        }

        .hidden-tier.revealed {
            height: auto;
            min-height: var(--hidden-tile-height, 200px);
        }

        .hidden-content {
            visibility: hidden;
            max-height: 0;
            overflow: hidden;
        }

        .hidden-tier.revealed .hidden-content {
            visibility: visible;
            max-height: none;
            overflow: visible;
        }

        .hidden-cover {
            position: absolute;
            inset: 0;
            z-index: 2;
            background: rgba(12, 12, 16, 0.88);
            border: 1px dashed rgba(201, 162, 39, 0.4);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0.5rem;
            transition: opacity 0.3s ease;
        }

        .hidden-discover {
            width: 100%;
            height: 100%;
            border: 1px solid rgba(201, 162, 39, 0.4);
            background: linear-gradient(135deg, rgba(22, 22, 26, 0.9), rgba(10, 10, 14, 0.85));
            color: var(--text-primary);
            display: flex;
            flex-direction: column;
            justify-content: center;
            gap: 0.4rem;
            font-size: 0.75rem;
        }

        .hidden-discover-title {
            font-family: var(--font-display);
            font-size: 0.78rem;
            letter-spacing: 0.12em;
            text-transform: uppercase;
            color: var(--accent-gold);
        }

        .hidden-discover-detail {
            font-size: 0.7rem;
            color: var(--text-muted);
            text-transform: none;
            letter-spacing: 0.02em;
            text-align: center;
        }

        .hidden-block {
            background: rgba(201, 162, 39, 0.08);
            border: 1px solid rgba(201, 162, 39, 0.3);
            border-radius: 4px;
            padding: 0.5rem 0.75rem;
            display: flex;
            align-items: baseline;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        .hidden-block h4 {
            font-family: var(--font-display);
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--accent-gold);
            margin: 0;
        }

        .hidden-items {
            display: flex;
            flex-wrap: wrap;
            gap: 0.25rem 0.5rem;
            font-size: 0.9rem;
            color: var(--text-primary);
        }

        .hidden-item {
            display: inline-flex;
            gap: 0.35rem;
            align-items: baseline;
        }

        .hidden-tag {
            font-size: 0.65rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            padding: 0.1rem 0.3rem;
            border-radius: 2px;
            background: rgba(0, 0, 0, 0.4);
            color: var(--text-muted);
        }

        .hidden-tag.common { color: #e5d7a3; }
        .hidden-tag.rare { color: #9fd1ff; }
        .hidden-tag.legendary { color: #f4b4ff; }

        .hidden-danger-block {
            background: rgba(139, 38, 53, 0.08);
            border: 1px solid rgba(139, 38, 53, 0.4);
            border-radius: 4px;
            padding: 0.75rem;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .hidden-danger-title {
            font-family: var(--font-display);
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: var(--accent-red);
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 0.75rem;
            flex-wrap: wrap;
        }

        .hidden-danger-detail {
            font-size: 0.9rem;
            color: var(--text-muted);
        }

        .hidden-danger-block.resolved .hidden-danger-detail {
            display: none;
        }

        .resolve-toggle {
            display: inline-flex;
            align-items: center;
            gap: 0.35rem;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: var(--text-muted);
        }

        .resolve-toggle input {
            accent-color: var(--accent-gold);
        }

        /* Hidden Section - Success Threshold System */
        .hidden-header {
            display: flex;
            align-items: center;
            gap: 1.5rem;
            margin-bottom: 0.75rem;
            padding: 0.75rem 1rem;
            background: rgba(201, 162, 39, 0.05);
            border: 1px solid rgba(201, 162, 39, 0.2);
            border-radius: 4px;
            flex-wrap: wrap;
        }

        .hidden-threshold {
            font-family: var(--font-display);
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--accent-gold);
        }

        .hidden-threshold-value {
            font-size: 1.1rem;
            color: var(--text-primary);
        }

        .hidden-successes {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .hidden-successes-label {
            font-size: 0.8rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .success-checkboxes {
            display: flex;
            gap: 0.35rem;
        }

        .success-checkbox {
            width: 24px;
            height: 24px;
            appearance: none;
            -webkit-appearance: none;
            background: var(--bg-dark);
            border: 2px solid rgba(201, 162, 39, 0.4);
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }

        .success-checkbox:hover {
            border-color: var(--accent-gold);
        }

        .success-checkbox:checked {
            background: var(--accent-gold);
            border-color: var(--accent-gold);
        }

        .success-checkbox:checked::after {
            content: '';
            position: absolute;
            left: 6px;
            top: 2px;
            width: 6px;
            height: 12px;
            border: solid var(--bg-dark);
            border-width: 0 2px 2px 0;
            transform: rotate(45deg);
        }

        .success-checkbox-label {
            font-size: 0.7rem;
            color: var(--text-muted);
            text-align: center;
            width: 24px;
        }

        .success-box {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.2rem;
        }

        /* Visible loot (not hidden) */
        .visible-loot {
            margin-bottom: 0.75rem;
        }

        .visible-loot-title {
            font-family: var(--font-display);
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--text-muted);
            margin-bottom: 0.5rem;
        }

        /* Hidden items with reveal levels */
        .hidden-item-entry {
            display: none;
        }

        .hidden-item-entry.revealed {
            display: block;
        }

        .threat-list {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .threat-block {
            background: rgba(139, 38, 53, 0.1);
            border: 1px solid var(--accent-red);
            border-radius: 4px;
            padding: 1rem;
        }

        .threat-block.boss {
            background: linear-gradient(135deg, rgba(139, 38, 53, 0.2), rgba(201, 162, 39, 0.1));
            border-color: var(--accent-gold);
            box-shadow: 0 0 20px rgba(201, 162, 39, 0.1);
        }

        .threat-header {
            font-family: var(--font-display);
            font-size: 1.1rem;
            color: var(--text-primary);
            margin-bottom: 0.75rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 0.75rem;
            flex-wrap: wrap;
        }

        .threat-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 0.5rem;
            margin-bottom: 0.75rem;
            font-size: 0.9rem;
        }

        .threat-stat {
            display: flex;
            gap: 0.5rem;
        }

        .stat-label {
            color: var(--text-muted);
        }

        .threat-abilities {
            padding-top: 0.5rem;
            border-top: 1px solid rgba(139, 38, 53, 0.3);
        }

        .threat-block.resolved {
            padding: 0.75rem;
        }

        .threat-block.resolved .threat-stats,
        .threat-block.resolved .threat-abilities {
            display: none;
        }

        .threat-block.resolved .threat-header {
            margin-bottom: 0;
        }

        .danger-reveal-box {
            border: 1px solid rgba(201, 162, 39, 0.3);
            border-radius: 4px;
            padding: 0.75rem;
            background: rgba(0, 0, 0, 0.2);
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .ability {
            font-size: 0.9rem;
            color: var(--text-muted);
            padding: 0.25rem 0;
        }

        .ability-name {
            color: var(--accent-gold);
        }

        .no-threats {
            color: var(--text-muted);
            font-style: italic;
            padding: 1rem;
            text-align: center;
            background: rgba(0,0,0,0.2);
            border-radius: 2px;
        }

        .empty-state {
            padding: 3rem 1.5rem;
            text-align: center;
            color: var(--text-muted);
        }

        .empty-state p {
            margin-bottom: 1rem;
        }

        .data-status {
            font-size: 0.85rem;
            color: var(--text-muted);
            padding: 0.5rem 1rem;
            background: rgba(0,0,0,0.3);
            border-radius: 2px;
            margin-bottom: 1rem;
        }

        .data-status.loaded {
            color: var(--accent-green);
            border-left: 3px solid var(--accent-green);
        }

        .data-status.default {
            border-left: 3px solid var(--accent-gold-dim);
        }

        .data-status.warning {
            color: var(--accent-red);
            border-left: 3px solid var(--accent-red);
        }

        .error {
            background: var(--danger);
            padding: 1rem;
            border-radius: 4px;
            margin-bottom: 1rem;
        }

        .potency-competent { color: #6b9b6b; }
        .potency-effective { color: #9b9b6b; }
        .potency-forceful { color: #9b6b6b; }

        .hidden { display: none !important; }

        .exit-actions {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
            margin-left: auto;
        }

        .exit-action {
            font-size: 0.65rem;
            padding: 0.4rem 0.6rem;
        }

        .map-panel {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 4px;
            overflow: hidden;
        }

        .map-header {
            padding: 1rem 1.5rem;
            background: rgba(0,0,0,0.3);
            font-family: var(--font-display);
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 0.15em;
            color: var(--accent-gold);
            border-bottom: 1px solid var(--border);
        }

        .map-body {
            padding: 1rem;
        }

        .map-grid {
            position: relative;
            background-image:
                linear-gradient(transparent 69px, rgba(255, 255, 255, 0.05) 70px),
                linear-gradient(90deg, transparent 69px, rgba(255, 255, 255, 0.05) 70px);
            background-size: 70px 70px;
            border: 1px solid var(--border);
            border-radius: 2px;
            overflow: auto;
            min-height: 220px;
        }

        .map-rooms {
            position: relative;
        }

        .map-room {
            position: absolute;
            width: var(--room-size, 140px);
            height: var(--room-size, 140px);
            border: 1px solid rgba(201, 162, 39, 0.3);
            border-radius: 2px;
            overflow: hidden;
            box-shadow: 0 0 10px rgba(0,0,0,0.4);
        }

        .map-room img {
            width: 100%;
            height: 100%;
            transform-origin: center;
        }

        .map-room.current {
            outline: 3px solid var(--accent-gold);
            box-shadow: 0 0 20px rgba(201, 162, 39, 0.4);
        }

        .map-room.start {
            outline: 2px dashed var(--accent-green);
        }

        .map-room.boss {
            outline: 2px solid var(--accent-red);
        }

        .map-room-label {
            position: absolute;
            bottom: 4px;
            left: 4px;
            padding: 0.2rem 0.4rem;
            background: rgba(0,0,0,0.6);
            font-size: 0.65rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .map-room-label span {
            color: var(--accent-gold);
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Strive Dungeon</h1>
            <p class="subtitle">GM-less Procedural Dungeon Generator</p>
        </header>

        <div id="dataStatus" class="data-status default">Loading dungeon data...</div>
        <div id="errorDisplay" class="error hidden"></div>

        <details class="setup-panel" open>
            <summary>Dungeon Setup</summary>
            <div class="controls">
                <div class="control-group">
                    <label for="difficulty">Difficulty</label>
                    <select id="difficulty">
                        <option value="Easy">Easy</option>
                        <option value="Medium" selected>Medium</option>
                        <option value="Hard">Hard</option>
                        <option value="Deadly">Deadly</option>
                    </select>
                </div>
                <div class="control-group">
                    <label for="dungeonLength">Dungeon Length (rooms)</label>
                    <input type="number" id="dungeonLength" min="6" max="30" value="10">
                </div>
                <div class="control-group full-width keyword-group">
                    <label>Threat Keyword 1</label>
                    <div class="keyword-row">
                        <input type="text" id="threatKeyword1" placeholder="e.g., Goblin" class="keyword-input">
                        <input type="text" id="keywordAbility1_1" list="abilityList" placeholder="Ability 1" class="ability-input">
                        <input type="text" id="keywordAbility1_2" list="abilityList" placeholder="Ability 2" class="ability-input">
                        <input type="text" id="keywordAbility1_3" list="abilityList" placeholder="Ability 3" class="ability-input">
                    </div>
                </div>
                <div class="control-group full-width keyword-group">
                    <label>Threat Keyword 2 (optional)</label>
                    <div class="keyword-row">
                        <input type="text" id="threatKeyword2" placeholder="e.g., Ogre" class="keyword-input">
                        <input type="text" id="keywordAbility2_1" list="abilityList" placeholder="Ability 1" class="ability-input">
                        <input type="text" id="keywordAbility2_2" list="abilityList" placeholder="Ability 2" class="ability-input">
                        <input type="text" id="keywordAbility2_3" list="abilityList" placeholder="Ability 3" class="ability-input">
                    </div>
                </div>
                <datalist id="abilityList"></datalist>
                <div class="control-group full-width">
                    <label>Threat Type Filters</label>
                    <div class="threat-filter-row">
                        <button type="button" id="threatFilterBtn">Disallowed Threat Types</button>
                        <span id="threatFilterSummary" class="helper-text">No disallowed threat types.</span>
                    </div>
                </div>
                <div class="control-group full-width">
                    <label>Vibe Themes</label>
                    <div class="filter-row">
                        <button type="button" id="descriptionFilterBtn">Vibe Themes</button>
                        <span id="descriptionFilterSummary" class="helper-text">No vibe themes selected.</span>
                    </div>
                </div>
                <div class="control-group">
                    <label for="dataFile">Import Data File</label>
                    <input type="file" id="dataFile" accept=".json">
                </div>
                <div class="control-group">
                    <label for="pngFolder">Load PNG Folder</label>
                    <input type="file" id="pngFolder" webkitdirectory directory>
                </div>
            </div>

            <div class="buttons">
                <button class="primary" id="startBtn">Start New Dungeon</button>
                <button id="exportBtn" disabled>Export Dungeon (JSON)</button>
            </div>
        </details>

        <div class="dice-roller">
            <span class="dice-roller-title">Dice Roller</span>
            <div class="dice-section">
                <button class="dice-control-btn" id="removeDieBtn" title="Remove die">âˆ’</button>
                <div class="dice-container" id="diceContainer">
                    <!-- Dice will be dynamically generated -->
                </div>
                <button class="dice-control-btn" id="addDieBtn" title="Add die">+</button>
            </div>
            <div class="dice-actions">
                <button class="roll-button" id="rollDiceBtn">Roll Dice</button>
                <button class="rest-button" id="restBtn">Rest</button>
            </div>
        </div>

        <div class="main-content">
            <div class="current-room" id="currentRoomPanel">
                <div class="empty-state" id="emptyState">
                    <p>No dungeon started yet.</p>
                    <p>Configure your settings above and click "Start New Dungeon" to begin.</p>
                </div>
                <div id="roomContent" class="hidden"></div>
            </div>

            <div class="map-panel">
                <div class="map-header">Dungeon Map</div>
                <div class="map-body">
                    <div id="mapEmpty" class="empty-state">
                        <p>Rooms will reveal themselves here as you explore.</p>
                    </div>
                    <div id="pngStatus" class="data-status default hidden"></div>
                    <div id="mapGrid" class="map-grid hidden">
                        <div id="mapRooms" class="map-rooms"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="threatFilterModal" class="modal hidden" role="dialog" aria-modal="true" aria-labelledby="threatFilterTitle">
        <div class="modal-card">
            <div class="modal-header">
                <div class="modal-title" id="threatFilterTitle">Disallowed Threat Types</div>
                <button type="button" id="closeThreatFilter">Close</button>
            </div>
            <div class="modal-body">
                <p class="helper-text">Checked types will never appear in generated encounters (including bosses).</p>
                <div class="threat-filter-row modal-actions">
                    <button type="button" id="selectAllThreats">Select All</button>
                    <button type="button" id="clearAllThreats">Clear All</button>
                </div>
                <div id="threatTypeList" class="threat-type-list"></div>
            </div>
            <div class="modal-footer">
                <button type="button" id="applyThreatFilter">Done</button>
            </div>
        </div>
    </div>

    <div id="descriptionFilterModal" class="modal hidden" role="dialog" aria-modal="true" aria-labelledby="descriptionFilterTitle">
        <div class="modal-card">
            <div class="modal-header">
                <div class="modal-title" id="descriptionFilterTitle">Vibe Themes</div>
                <button type="button" id="closeDescriptionFilter">Close</button>
            </div>
            <div class="modal-body">
                <p class="helper-text">Selected themes add flavorful details to every room description.</p>
                <div class="filter-row modal-actions">
                    <button type="button" id="selectAllDescriptions">Select All</button>
                    <button type="button" id="clearAllDescriptions">Clear All</button>
                </div>
                <div id="descriptionFilterList" class="threat-type-list"></div>
            </div>
            <div class="modal-footer">
                <button type="button" id="applyDescriptionFilter">Done</button>
            </div>
        </div>
    </div>

    <div id="dangerRevealModal" class="modal hidden" role="dialog" aria-modal="true" aria-labelledby="dangerRevealTitle">
        <div class="modal-card">
            <div class="modal-header">
                <div class="modal-title" id="dangerRevealTitle">Hidden Danger Revealed</div>
                <button type="button" id="closeDangerReveal">Close</button>
            </div>
            <div class="modal-body">
                <p class="helper-text" id="dangerRevealIntro">Hidden dangers emerge as you attempt to move on.</p>
                <div id="dangerRevealList" class="danger-reveal-box"></div>
            </div>
            <div class="modal-footer">
                <button type="button" id="dismissDangerReveal">Understood</button>
            </div>
        </div>
    </div>

    <div id="restModal" class="modal hidden" role="dialog" aria-modal="true" aria-labelledby="restTitle">
        <div class="modal-card">
            <div class="modal-header">
                <div class="modal-title" id="restTitle">Rest</div>
                <button type="button" id="closeRestModal">Close</button>
            </div>
            <div class="modal-body">
                <p class="helper-text">Choose how long you wish to rest. Longer rests have a higher chance of being interrupted by wandering threats.</p>
                <div class="rest-time-selector">
                    <div class="rest-time-row">
                        <span class="rest-time-label">Hours:</span>
                        <div class="rest-time-input">
                            <input type="number" id="restHours" min="0" max="12" value="0">
                        </div>
                        <div class="rest-quarters">
                            <button type="button" class="rest-quarter-btn" data-quarters="0">:00</button>
                            <button type="button" class="rest-quarter-btn" data-quarters="1">:15</button>
                            <button type="button" class="rest-quarter-btn" data-quarters="2">:30</button>
                            <button type="button" class="rest-quarter-btn" data-quarters="3">:45</button>
                        </div>
                    </div>
                    <div class="rest-total" id="restTotal">Total: 0 minutes</div>
                    <p class="rest-warning">Hidden threats and traps not yet discovered may also interrupt your rest.</p>
                </div>
                <div id="restResult" class="hidden"></div>
            </div>
            <div class="modal-footer">
                <button type="button" id="restNowBtn" class="primary">Rest Now</button>
            </div>
        </div>
    </div>

    <script>
        // ==================== DATA LOADING ====================
        const DEFAULT_DATA_PATH = 'dungeon_data_expanded.json';
        let baseGameData = null;

        // ==================== STATE ====================
        let gameData = null;
        let dungeonState = null;
        let usedLayouts = { Rooms: [], Halls: [], "Dead Ends": [], "Exits": [] };
        const pngCache = {};
        const missingPngPaths = new Set();
        const directionVectors = {
            N: { x: 0, y: -1 },
            E: { x: 1, y: 0 },
            S: { x: 0, y: 1 },
            W: { x: -1, y: 0 }
        };
        const directionLabels = {
            N: 'North',
            E: 'East',
            S: 'South',
            W: 'West'
        };

        // ==================== UTILITIES ====================
        function randInt(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        // ==================== DICE ROLLER ====================
        const DICE_COLORS = ['blue', 'red', 'green', 'black', 'purple'];
        const DEFAULT_DICE = ['red', 'blue', 'green'];
        const MIN_DICE = 1;
        const MAX_DICE = 6;

        // Dice state (reset on page reload)
        let diceState = DEFAULT_DICE.map(color => ({ color, value: '-' }));

        function rollD6() {
            return Math.floor(Math.random() * 6) + 1;
        }

        function getNextColor(currentColor) {
            const currentIndex = DICE_COLORS.indexOf(currentColor);
            const nextIndex = (currentIndex + 1) % DICE_COLORS.length;
            return DICE_COLORS[nextIndex];
        }

        function renderDice() {
            const container = document.getElementById('diceContainer');
            container.innerHTML = '';

            diceState.forEach((die, index) => {
                const dieEl = document.createElement('div');
                dieEl.className = `die ${die.color}`;
                dieEl.dataset.index = index;
                dieEl.innerHTML = `<span class="die-value">${die.value}</span>`;
                dieEl.addEventListener('click', () => cycleDieColor(index));
                container.appendChild(dieEl);
            });

            updateDiceControls();
        }

        function cycleDieColor(index) {
            diceState[index].color = getNextColor(diceState[index].color);
            renderDice();
        }

        function addDie() {
            if (diceState.length < MAX_DICE) {
                diceState.push({ color: 'black', value: '-' });
                renderDice();
            }
        }

        function removeDie() {
            if (diceState.length > MIN_DICE) {
                diceState.pop();
                renderDice();
            }
        }

        function updateDiceControls() {
            const addBtn = document.getElementById('addDieBtn');
            const removeBtn = document.getElementById('removeDieBtn');

            if (addBtn) addBtn.disabled = diceState.length >= MAX_DICE;
            if (removeBtn) removeBtn.disabled = diceState.length <= MIN_DICE;
        }

        function rollAllDice() {
            const diceElements = document.querySelectorAll('.dice-container .die');

            // Add rolling animation
            diceElements.forEach(die => {
                die.classList.add('rolling');
            });

            // Roll after animation
            setTimeout(() => {
                diceState.forEach((die, index) => {
                    die.value = rollD6();
                });

                diceElements.forEach((dieEl, index) => {
                    dieEl.querySelector('.die-value').textContent = diceState[index].value;
                    dieEl.classList.remove('rolling');
                });
            }, 400);
        }

        function initDiceRoller() {
            renderDice();

            document.getElementById('addDieBtn').addEventListener('click', addDie);
            document.getElementById('removeDieBtn').addEventListener('click', removeDie);
            document.getElementById('rollDiceBtn').addEventListener('click', rollAllDice);
        }

        // ==================== REST SYSTEM ====================
        let restState = {
            hours: 0,
            quarters: 0
        };

        function getRestTotalMinutes() {
            return restState.hours * 60 + restState.quarters * 15;
        }

        function updateRestTotal() {
            const totalMinutes = getRestTotalMinutes();
            const hours = Math.floor(totalMinutes / 60);
            const minutes = totalMinutes % 60;

            let displayText = '';
            if (hours > 0 && minutes > 0) {
                displayText = `Total: ${hours} hour${hours > 1 ? 's' : ''} ${minutes} minutes`;
            } else if (hours > 0) {
                displayText = `Total: ${hours} hour${hours > 1 ? 's' : ''}`;
            } else if (minutes > 0) {
                displayText = `Total: ${minutes} minutes`;
            } else {
                displayText = 'Total: 0 minutes';
            }

            document.getElementById('restTotal').textContent = displayText;
        }

        function hasUndiscoveredDangers() {
            if (!dungeonState || !dungeonState.currentRoomId) return false;
            const room = dungeonState.rooms.find(r => r.id === dungeonState.currentRoomId);
            if (!room) return false;

            const revealedLevel = room.revealedSuccessLevel || 0;

            // Check for hidden threats
            for (let i = 0; i < room.threats.length; i++) {
                const threat = room.threats[i];
                if (isHiddenThreat(threat)) {
                    const hiddenId = `threat-${i}`;
                    const requirement = room.hiddenReveal?.[hiddenId];
                    const threatHiddenLevel = requirement?.successes || 2;
                    if (threatHiddenLevel > revealedLevel && !requirement?.revealed) {
                        return true;
                    }
                }
            }

            // Check for trapped doors
            for (const [direction, door] of Object.entries(room.doors || {})) {
                if (door.status === 'Trapped') {
                    const hiddenId = `door-trap-${direction}`;
                    const requirement = room.hiddenReveal?.[hiddenId];
                    const trapHiddenLevel = requirement?.successes || 1;
                    if (trapHiddenLevel > revealedLevel && !requirement?.revealed) {
                        return true;
                    }
                }
            }

            return false;
        }

        function calculateRestInterruption(totalMinutes) {
            // Hidden dangers always interrupt
            if (hasUndiscoveredDangers()) {
                // Interrupt immediately (or at a random early point)
                const interruptTime = Math.min(totalMinutes, randInt(5, Math.max(15, Math.floor(totalMinutes / 4))));
                return {
                    interrupted: true,
                    reason: 'hidden_danger',
                    timeRested: interruptTime
                };
            }

            // Calculate wandering monster chance
            // First 15 min: 1/6, at 1 hour mark: 1/6, then 2/6 per hour after
            let currentTime = 0;
            const checkPoints = [];

            // First 15 minutes check
            if (totalMinutes >= 15) {
                checkPoints.push({ time: 15, chance: 1/6 });
            }

            // Hour marks
            for (let hour = 1; hour <= Math.ceil(totalMinutes / 60); hour++) {
                const checkTime = hour * 60;
                if (checkTime <= totalMinutes) {
                    // First hour: 1/6, subsequent hours: 2/6
                    const chance = hour === 1 ? 1/6 : 2/6;
                    checkPoints.push({ time: checkTime, chance });
                }
            }

            // Roll for each checkpoint
            for (const checkpoint of checkPoints) {
                if (Math.random() < checkpoint.chance) {
                    // Interrupted at this checkpoint
                    return {
                        interrupted: true,
                        reason: 'wandering',
                        timeRested: checkpoint.time
                    };
                }
            }

            // No interruption
            return {
                interrupted: false,
                timeRested: totalMinutes
            };
        }

        function calculateRecovery(minutes) {
            const recoveryPoints = Math.floor(minutes / 15);
            const striveDice = Math.floor(minutes / 30);
            return { recoveryPoints, striveDice };
        }

        function performRest() {
            const totalMinutes = getRestTotalMinutes();

            if (totalMinutes <= 0) {
                return;
            }

            const result = calculateRestInterruption(totalMinutes);
            const recovery = calculateRecovery(result.timeRested);

            const resultDiv = document.getElementById('restResult');
            resultDiv.classList.remove('hidden');

            if (result.interrupted) {
                const reasonText = result.reason === 'hidden_danger'
                    ? 'Your rest was interrupted by a hidden danger!'
                    : 'Your rest was interrupted by wandering threats!';

                resultDiv.innerHTML = `
                    <div class="rest-result interrupted">
                        <div class="rest-result-title">Rest Interrupted!</div>
                        <div class="rest-result-detail">${reasonText}</div>
                        <div class="rest-result-detail">You rested for ${result.timeRested} minutes before the interruption.</div>
                        <div class="rest-recovery">
                            <strong>${recovery.recoveryPoints} Recovery Points</strong> and <strong>${recovery.striveDice} Strive Dice</strong>
                        </div>
                    </div>
                `;
            } else {
                resultDiv.innerHTML = `
                    <div class="rest-result success">
                        <div class="rest-result-title">Rest Complete</div>
                        <div class="rest-result-detail">You rested undisturbed for ${result.timeRested} minutes.</div>
                        <div class="rest-recovery">
                            <strong>${recovery.recoveryPoints} Recovery Points</strong> and <strong>${recovery.striveDice} Strive Dice</strong>
                        </div>
                    </div>
                `;
            }
        }

        function openRestModal() {
            restState = { hours: 0, quarters: 0 };
            document.getElementById('restHours').value = 0;
            document.querySelectorAll('.rest-quarter-btn').forEach(btn => btn.classList.remove('selected'));
            document.querySelector('.rest-quarter-btn[data-quarters="0"]').classList.add('selected');
            document.getElementById('restResult').classList.add('hidden');
            document.getElementById('restResult').innerHTML = '';
            updateRestTotal();
            document.getElementById('restModal').classList.remove('hidden');
        }

        function closeRestModal() {
            document.getElementById('restModal').classList.add('hidden');
        }

        function initRestSystem() {
            document.getElementById('restBtn').addEventListener('click', openRestModal);
            document.getElementById('closeRestModal').addEventListener('click', closeRestModal);
            document.getElementById('restNowBtn').addEventListener('click', performRest);

            document.getElementById('restHours').addEventListener('input', (e) => {
                restState.hours = Math.max(0, Math.min(12, parseInt(e.target.value) || 0));
                e.target.value = restState.hours;
                updateRestTotal();
            });

            document.querySelectorAll('.rest-quarter-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.rest-quarter-btn').forEach(b => b.classList.remove('selected'));
                    btn.classList.add('selected');
                    restState.quarters = parseInt(btn.dataset.quarters);
                    updateRestTotal();
                });
            });

            // Close modal when clicking outside
            document.getElementById('restModal').addEventListener('click', (e) => {
                if (e.target.id === 'restModal') {
                    closeRestModal();
                }
            });
        }

        function pick(arr) {
            return arr[Math.floor(Math.random() * arr.length)];
        }

        function weightedPick(weights) {
            const total = Object.values(weights).reduce((a, b) => a + b, 0);
            let r = Math.random() * total;
            for (const [key, weight] of Object.entries(weights)) {
                r -= weight;
                if (r <= 0) return key;
            }
            return Object.keys(weights)[0];
        }

        function clampRarityWeights(weights) {
            const clamped = { ...weights };
            Object.keys(clamped).forEach(key => {
                if (clamped[key] < 1) clamped[key] = 1;
            });
            return clamped;
        }

        function adjustRarityWeights(baseWeights, hasEncounter, isBoss) {
            const adjusted = { ...baseWeights };
            if (hasEncounter) {
                adjusted.Common -= 10;
                adjusted.Rare += 7;
                adjusted.Legendary += 3;
            }
            if (isBoss) {
                adjusted.Common -= 10;
                adjusted.Rare += 5;
                adjusted.Legendary += 5;
            }
            return clampRarityWeights(adjusted);
        }

        function getLootData() {
            return gameData?.lootData || { magic: {}, mundane: {} };
        }

        function getLootRarityWeights() {
            return gameData?.lootRarityWeights || {};
        }

        function getLootRevealThresholdRange() {
            return gameData?.lootRevealThresholdRange || { min: 3, max: 5 };
        }

        function getLootRevealTiers() {
            return gameData?.lootRevealTiers || {};
        }

        async function loadBaseGameData() {
            const dataStatus = document.getElementById('dataStatus');
            dataStatus.textContent = 'Loading dungeon data...';
            dataStatus.className = 'data-status default';

            try {
                const response = await fetch(DEFAULT_DATA_PATH, { cache: 'no-store' });
                if (!response.ok) {
                    throw new Error(`Failed to load ${DEFAULT_DATA_PATH}`);
                }
                const data = await response.json();
                baseGameData = data;
                gameData = JSON.parse(JSON.stringify(baseGameData));
                dataStatus.textContent = `Loaded: ${DEFAULT_DATA_PATH}`;
                dataStatus.className = 'data-status loaded';
            } catch (err) {
                dataStatus.textContent = `Failed to load ${DEFAULT_DATA_PATH}`;
                dataStatus.className = 'data-status warning';
                document.getElementById('errorDisplay').textContent = `Error loading data: ${err.message}`;
                document.getElementById('errorDisplay').classList.remove('hidden');
                baseGameData = null;
                gameData = null;
            }
        }

        function formatCoins(coins) {
            if (!coins) return '';
            const total = typeof coins === 'number'
                ? coins
                : typeof coins === 'string'
                    ? parseInt(coins, 10)
                    : typeof coins.total === 'string'
                        ? parseInt(coins.total, 10)
                        : coins.total;
            return Number.isFinite(total) ? `${total} Coins` : '';
        }

        function article(word) {
            // Returns "a" or "an" based on whether the word starts with a vowel sound
            const vowels = ['a', 'e', 'i', 'o', 'u'];
            const firstLetter = word.trim().toLowerCase().charAt(0);
            return vowels.includes(firstLetter) ? 'an' : 'a';
        }

        function getLayoutCode(layoutId) {
            const match = layoutId.match(/^([A-Z]+)/);
            return match ? match[1] : "D";
        }

        function getExitsForLayout(layoutId) {
            const code = getLayoutCode(layoutId);
            return gameData.layoutExits[code] || [];
        }

        function coordKey(x, y) {
            return `${x},${y}`;
        }

        function getOppositeDirection(dir) {
            const opposites = { N: 'S', S: 'N', E: 'W', W: 'E' };
            return opposites[dir];
        }

        function getRotationForMove(moveDir) {
            const rotations = { E: 0, W: 180, N: -90, S: 90 };
            return rotations[moveDir] ?? 0;
        }

        function rotateDirection(dir, rotationDeg) {
            const order = ['N', 'E', 'S', 'W'];
            const index = order.indexOf(dir);
            if (index === -1) return dir;
            const steps = ((rotationDeg / 90) % 4 + 4) % 4;
            return order[(index + steps) % 4];
        }

        function rotateExits(exits, rotationDeg) {
            return exits.map(exit => rotateDirection(exit, rotationDeg));
        }

        function randomRotation() {
            const rotations = [0, 90, 180, 270];
            return pick(rotations);
        }

        function normalizePngPath(path) {
            if (!path) return path;
            const normalized = path.replace(/\\/g, '/');
            const pngIndex = normalized.indexOf('png/');
            if (pngIndex >= 0) {
                return normalized.slice(pngIndex);
            }
            return normalized.split('/').pop();
        }

        function getPngSrc(path) {
            const normalized = normalizePngPath(path);
            return pngCache[normalized] || path;
        }

        function updatePngStatus() {
            const status = document.getElementById('pngStatus');
            if (!status) return;
            if (missingPngPaths.size === 0) {
                status.classList.add('hidden');
                return;
            }
            status.className = 'data-status warning';
            status.textContent = `Missing PNGs (${missingPngPaths.size}). Load the png folder if running from local files.`;
            status.classList.remove('hidden');
        }

        function getRoomByPosition(position) {
            if (!dungeonState || !dungeonState.map) return null;
            const key = coordKey(position.x, position.y);
            const roomId = dungeonState.map[key];
            return dungeonState.rooms.find(room => room.id === roomId) || null;
        }

        function getCurrentRoom() {
            if (!dungeonState) return null;
            return dungeonState.rooms.find(room => room.id === dungeonState.currentRoomId) || null;
        }

        function getAvailableExpansionDirections(position, exits) {
            return exits.filter(dir => {
                const vec = directionVectors[dir];
                const nextPos = { x: position.x + vec.x, y: position.y + vec.y };
                return !dungeonState.map[coordKey(nextPos.x, nextPos.y)];
            });
        }

        function getFrontierCount() {
            if (!dungeonState) return 0;
            let count = 0;
            dungeonState.rooms.forEach(room => {
                room.exits.forEach(exit => {
                    const vec = directionVectors[exit];
                    const nextPos = { x: room.position.x + vec.x, y: room.position.y + vec.y };
                    if (!dungeonState.map[coordKey(nextPos.x, nextPos.y)]) {
                        count += 1;
                    }
                });
            });
            return count;
        }

        function roomHasExit(room, direction) {
            if (!room) return false;
            return room.exits.includes(direction) || room.entryDir === direction;
        }

        function ensureExit(room, direction) {
            if (!room) return;
            if (!room.exits.includes(direction)) {
                room.exits.push(direction);
            }
            if (!room.doors) room.doors = {};
            if (!room.doors[direction]) {
                room.doors[direction] = { status: 'Open', bypass: null };
            }
        }

        function syncDoorPair(room, direction, neighbor) {
            if (!room || !neighbor) return;
            const oppositeDir = getOppositeDirection(direction);
            if (!room.doors) room.doors = {};
            if (!neighbor.doors) neighbor.doors = {};
            const sharedDoor = room.doors[direction] || neighbor.doors[oppositeDir] || { status: 'Open', bypass: null };
            room.doors[direction] = sharedDoor;
            neighbor.doors[oppositeDir] = sharedDoor;
            ensureExit(room, direction);
            ensureExit(neighbor, oppositeDir);
        }

        function linkAdjacentDoors(room) {
            if (!room) return;
            Object.keys(directionVectors).forEach(dir => {
                const vec = directionVectors[dir];
                const neighborPos = { x: room.position.x + vec.x, y: room.position.y + vec.y };
                const neighbor = getRoomByPosition(neighborPos);
                if (!neighbor) return;
                const oppositeDir = getOppositeDirection(dir);
                if (roomHasExit(room, dir) || roomHasExit(neighbor, oppositeDir)) {
                    syncDoorPair(room, dir, neighbor);
                }
            });
        }

        function getLinkedNeighborDirections(room) {
            if (!room) return [];
            return Object.keys(directionVectors).filter(dir => {
                if (!roomHasExit(room, dir)) {
                    return false;
                }
                const vec = directionVectors[dir];
                const neighborPos = { x: room.position.x + vec.x, y: room.position.y + vec.y };
                const neighbor = getRoomByPosition(neighborPos);
                return neighbor ? roomHasExit(neighbor, getOppositeDirection(dir)) : false;
            });
        }

        function getNeighborExitConstraints(position) {
            const requiredExits = new Set();
            const forbiddenExits = new Set();
            Object.keys(directionVectors).forEach(dir => {
                const vec = directionVectors[dir];
                const neighborPos = { x: position.x + vec.x, y: position.y + vec.y };
                const neighbor = getRoomByPosition(neighborPos);
                if (!neighbor) return;
                const oppositeDir = getOppositeDirection(dir);
                if (roomHasExit(neighbor, oppositeDir)) {
                    requiredExits.add(dir);
                } else {
                    forbiddenExits.add(dir);
                }
            });
            return { requiredExits, forbiddenExits };
        }

        function layoutMatchesConstraints(exits, constraints) {
            const exitSet = new Set(exits);
            for (const required of constraints.requiredExits) {
                if (!exitSet.has(required)) {
                    return false;
                }
            }
            for (const forbidden of constraints.forbiddenExits) {
                if (exitSet.has(forbidden)) {
                    return false;
                }
            }
            return true;
        }

        function applyExitConstraints(exits, constraints) {
            const adjusted = new Set(exits);
            constraints.forbiddenExits.forEach(dir => adjusted.delete(dir));
            constraints.requiredExits.forEach(dir => adjusted.add(dir));
            return Array.from(adjusted);
        }

        // ==================== LAYOUT SELECTION ====================
        function selectLayout({ isBossRoom, minExits, includeDeadEnds }) {
            // Boss rooms always use exit layouts
            if (isBossRoom) {
                const exitLayouts = gameData.layouts["Exits"] || [];
                const availableExits = exitLayouts.filter(id => !usedLayouts["Exits"].includes(id));
                if (availableExits.length > 0) {
                    const layoutId = pick(availableExits);
                    usedLayouts["Exits"].push(layoutId);
                    return { bucket: "Exits", layoutId };
                }
                // If all exits used, reset and pick again
                usedLayouts["Exits"] = [];
                const layoutId = pick(exitLayouts);
                usedLayouts["Exits"].push(layoutId);
                return { bucket: "Exits", layoutId };
            }

            // For non-boss rooms, include exits with small chance when dead ends are allowed
            const includeExits = includeDeadEnds && Math.random() < 0.05;
            const buckets = ["Rooms", "Halls",
                ...(includeDeadEnds ? ["Dead Ends"] : []),
                ...(includeExits ? ["Exits"] : [])];

            const bucketWeights = {
                "Rooms": 50,
                "Halls": 35,
                ...(includeDeadEnds ? { "Dead Ends": 12 } : {}),
                ...(includeExits ? { "Exits": 3 } : {})
            };

            const bucket = weightedPick(bucketWeights);
            const available = (gameData.layouts[bucket] || []).filter(id => {
                if (usedLayouts[bucket] && usedLayouts[bucket].includes(id)) return false;
                const exits = getExitsForLayout(id);
                return exits.length >= minExits;
            });

            if (available.length === 0) {
                if (!usedLayouts[bucket]) usedLayouts[bucket] = [];
                usedLayouts[bucket] = [];
                return selectLayout({ isBossRoom, minExits, includeDeadEnds });
            }

            const layoutId = pick(available);
            if (!usedLayouts[bucket]) usedLayouts[bucket] = [];
            usedLayouts[bucket].push(layoutId);

            return { bucket, layoutId };
        }

        // ==================== DESCRIPTION GENERATION ====================
        function getDescriptionPool(categoryKey) {
            const selectedThemes = dungeonState?.descriptionThemes || [];
            const themeBuckets = gameData.descriptionThemes || {};
            if (selectedThemes.length > 0 && Object.keys(themeBuckets).length > 0) {
                const themedEntries = selectedThemes.flatMap(themeKey => {
                    const themeData = themeBuckets[themeKey];
                    if (!themeData || !Array.isArray(themeData[categoryKey])) {
                        return [];
                    }
                    return themeData[categoryKey];
                });
                if (themedEntries.length > 0) {
                    return themedEntries;
                }
            }
            return gameData[categoryKey] || [];
        }

        function generateDescription() {
            const leadIn = pick(getDescriptionPool('leadIns'));
            const roomType = pick(getDescriptionPool('roomTypes'));
            const underfoot = pick(getDescriptionPool('sensesUnderfoot'));

            // Pick one other sense type
            const otherSenses = [
                getDescriptionPool('sensesAir'),
                getDescriptionPool('sensesSound'),
                getDescriptionPool('sensesLight')
            ];
            const otherSense = pick(pick(otherSenses));

            const anchor = pick(getDescriptionPool('anchorFeatures'));
            const interaction = pick(getDescriptionPool('interactions'));

            const selectedThemes = dungeonState?.descriptionThemes || [];
            const themeFlair = selectedThemes.flatMap(themeKey => {
                const theme = descriptionThemeConfig.find(entry => entry.key === themeKey);
                return theme ? theme.phrases : [];
            });
            const flair = themeFlair.length > 0 ? ` ${pick(themeFlair)}` : '';

            return {
                text: `${leadIn} ${article(roomType)} ${roomType}; ${underfoot}, ${otherSense}. ${anchor} stands ${interaction}.${flair}`
            };
        }

        // ==================== DOOR GENERATION ====================
        function generateDoor(profile) {
            const status = pick(gameData.doorStatuses);

            if (status === "Open") {
                return { status, bypass: null };
            }

            const bypassInfo = gameData.doorBypassVerbs[status] || { verbs: ["overcome"] };
            const potency = weightedPick(profile.potencyWeights);
            const threshold = randInt(profile.baseThresholdRange.min, profile.baseThresholdRange.max);

            const door = {
                status,
                bypass: {
                    potency,
                    threshold,
                    verb: pick(bypassInfo.verbs)
                }
            };

            // Add trap damage for Trapped doors
            if (status === "Trapped") {
                door.trapDamage = randInt(profile.damageRange.min, profile.damageRange.max);
            }

            return door;
        }

        // ==================== THREAT GENERATION ====================
        function getAbilityDescription(abilityName) {
            // Look up the full ability description from the striveAbilities list
            const ability = gameData.striveAbilities.find(a => a.startsWith(abilityName + ':'));
            return ability || abilityName;
        }

        function generateEnvironmentalThreat(profile) {
            if (!gameData.environmentalThreats || gameData.environmentalThreats.length === 0) return null;

            const hazard = pick(gameData.environmentalThreats);
            const damage = randInt(profile.damageRange.min, profile.damageRange.max);
            const threshold = randInt(profile.baseThresholdRange.min, profile.baseThresholdRange.max);

            let successTiers = profile.successTiers;
            if (profile.successTiersWeak && Math.random() < 0.4) {
                successTiers = profile.successTiersWeak;
            }

            const hasCheck = Boolean(hazard.check);

            return {
                keyword: hazard.name,
                type: "Hazard",
                quantity: 1,
                damage,
                threshold,
                defeat: hasCheck ? null : successTiers.defeat,
                overwhelm: hasCheck ? null : successTiers.overwhelm,
                checkRequirement: hasCheck ? hazard.check : null,
                range: "",
                abilities: [hazard.description],
                isBoss: false,
                isHazard: true
            };
        }

        function maybeAddEnvironmentalThreat(threats, profile) {
            const chance = typeof gameData.environmentalThreatChance === 'number'
                ? gameData.environmentalThreatChance
                : 0;
            if (Math.random() >= chance) return;

            const hazard = generateEnvironmentalThreat(profile);
            if (hazard) {
                threats.push(hazard);
            }
        }

        function generateThreats(isBoss) {
            const profile = gameData.difficultyProfiles[dungeonState.difficulty];
            const keywords = dungeonState.keywords || [{ name: "Enemy", abilities: [] }];
            const disallowedTypes = new Set(dungeonState.disallowedThreatTypes || []);
            const allowedTypes = (gameData.typeWords || []).filter(type => !disallowedTypes.has(type));

            if (allowedTypes.length === 0) {
                const threats = [];
                maybeAddEnvironmentalThreat(threats, profile);
                return threats;
            }

            if (isBoss) {
                // Boss uses the first keyword
                const keywordData = keywords[0];
                const bossThreat = generateBossThreat(profile, keywordData.name, keywordData.abilities, allowedTypes);
                const bossThreats = bossThreat ? [bossThreat] : [];
                maybeAddEnvironmentalThreat(bossThreats, profile);
                return bossThreats;
            }

            const numTypes = randInt(profile.threatTypesRange.min, profile.threatTypesRange.max);
            if (numTypes === 0) {
                const threats = [];
                maybeAddEnvironmentalThreat(threats, profile);
                return threats;
            }

            const threats = [];
            const usedTypes = [];
            let totalThreatCount = 0;
            const maxThreats = profile.maxThreatsPerRoom || 99;

            for (let i = 0; i < numTypes; i++) {
                if (totalThreatCount >= maxThreats) break;

                const availableTypes = allowedTypes.filter(t => !usedTypes.includes(t));
                if (availableTypes.length === 0) break;

                const type = pick(availableTypes);
                usedTypes.push(type);

                // Pick a random keyword for this threat
                const keywordData = pick(keywords);
                const keyword = keywordData.name;
                const keywordAbilities = keywordData.abilities;

                // Calculate quantity, respecting max threats limit
                const remainingSlots = maxThreats - totalThreatCount;
                const maxQuantity = Math.min(profile.quantityRange.max, remainingSlots);
                const quantity = randInt(profile.quantityRange.min, maxQuantity);
                totalThreatCount += quantity;
                const damage = randInt(profile.damageRange.min, profile.damageRange.max);
                const threshold = randInt(profile.baseThresholdRange.min, profile.baseThresholdRange.max);

                // Determine success tiers - Hard/Deadly may use weaker tiers for variety
                let successTiers = profile.successTiers;
                if (profile.successTiersWeak && Math.random() < 0.4) {
                    successTiers = profile.successTiersWeak;
                }

                const abilities = [];
                if (gameData.wordToAbility[type]) {
                    abilities.push(gameData.wordToAbility[type]);
                }
                if (keywordAbilities.length > 0 && Math.random() < profile.keywordAbilityChance) {
                    const abilityName = pick(keywordAbilities);
                    abilities.push(getAbilityDescription(abilityName));
                }

                // Get range for this type - pick randomly if array
                const typeRangeValue = gameData.typeRange[type] || "Melee";
                const range = Array.isArray(typeRangeValue) ? pick(typeRangeValue) : typeRangeValue;

                const threat = {
                    keyword,
                    type,
                    quantity,
                    damage,
                    threshold,
                    defeat: successTiers.defeat,
                    overwhelm: successTiers.overwhelm,
                    range,
                    abilities,
                    isBoss: false
                };

                threats.push(threat);
            }

            maybeAddEnvironmentalThreat(threats, profile);
            return threats;
        }

        function generateBossThreat(profile, keyword, keywordAbilities, allowedTypes) {
            if (!allowedTypes || allowedTypes.length === 0) {
                return null;
            }
            const type = pick(allowedTypes);
            const baseDamage = profile.damageRange.max;
            const damage = baseDamage + profile.bossDamageBonus;
            const threshold = profile.baseThresholdRange.max;

            const abilities = [];
            if (gameData.wordToAbility[type]) {
                abilities.push(gameData.wordToAbility[type]);
            }
            // Boss always gets a keyword ability if available
            if (keywordAbilities.length > 0) {
                const abilityName = pick(keywordAbilities);
                abilities.push(getAbilityDescription(abilityName));
            }
            abilities.push("Heedless: This threat has no Defeat Tier and must be Overwhelmed to be defeated.");

            // Boss range - typically melee (all) or ranged (2)
            const bossRange = Math.random() < 0.5 ? "Melee (All)" : "Ranged (2)";

            return {
                keyword,
                type,
                quantity: 1,
                damage,
                threshold,
                defeat: profile.successTiers.defeat + profile.bossDefeatBonus,
                overwhelm: profile.successTiers.overwhelm + profile.bossOverwhelmBonus,
                range: bossRange,
                abilities,
                isBoss: true
            };
        }

        // ==================== LOOT GENERATION ====================
        function rollLootRarity(hasEncounter, isBoss) {
            const lootRarityWeights = getLootRarityWeights();
            const baseWeights = lootRarityWeights[dungeonState.difficulty] || lootRarityWeights.Medium;
            if (!baseWeights) {
                return "Common";
            }
            const adjusted = adjustRarityWeights(baseWeights, hasEncounter, isBoss);
            return weightedPick(adjusted);
        }

        function pickMagicItem(rarity, potionChance) {
            const lootData = getLootData();
            const pool = lootData.magic?.[rarity] || lootData.magic?.Common;
            if (!pool) {
                return { name: "Unknown Relic", category: "Magic", rarity };
            }
            const usePotion = pool.potions.length > 0 && Math.random() < potionChance;
            const name = usePotion ? pick(pool.potions) : pick(pool.items);
            return {
                name,
                category: "Magic",
                rarity
            };
        }

        function generateCoins(hasEncounter, isBoss) {
            const ranges = {
                Easy: { min: 10, max: 60 },
                Medium: { min: 25, max: 120 },
                Hard: { min: 60, max: 240 },
                Deadly: { min: 120, max: 400 }
            };
            const range = ranges[dungeonState.difficulty] || ranges.Medium;
            const multiplier = (hasEncounter ? 1.5 : 1) * (isBoss ? 2 : 1);
            const total = Math.max(1, Math.round(randInt(range.min, range.max) * multiplier));
            return { total };
        }

        function generateLoot(room) {
            const hasEncounter = room.threats && room.threats.length > 0;
            const isBoss = room.isBoss;
            const loot = { coins: null, items: [] };

            const coinChance = isBoss ? 1 : hasEncounter ? 0.85 : 0.55;
            if (Math.random() < coinChance) {
                loot.coins = generateCoins(hasEncounter, isBoss);
            }

            const mundaneCount = isBoss ? randInt(3, 5) : hasEncounter ? randInt(2, 3) : randInt(1, 2);
            for (let i = 0; i < mundaneCount; i++) {
                const lootData = getLootData();
                const pool = Math.random() < 0.55 ? lootData.mundane?.equipment : lootData.mundane?.supplies;
                loot.items.push({
                    name: pick(pool || []),
                    category: "Mundane"
                });
            }

            const trinketChance = isBoss ? 0.85 : hasEncounter ? 0.65 : 0.45;
            if (Math.random() < trinketChance) {
                loot.items.push({
                    name: pick(getLootData().mundane?.trinkets || []),
                    category: "Trinket"
                });
            }
            const gemChance = isBoss ? 0.75 : hasEncounter ? 0.6 : 0.35;
            if (Math.random() < gemChance) {
                loot.items.push({
                    name: pick(getLootData().mundane?.gemstones || []),
                    category: "Gemstone"
                });
            }

            const magicChance = isBoss ? 0.95 : hasEncounter ? 0.7 : 0.35;
            if (Math.random() < magicChance) {
                const magicCount = isBoss ? randInt(2, 3) : hasEncounter ? randInt(1, 2) : 1;
                const potionChance = isBoss ? 0.7 : hasEncounter ? 0.6 : 0.45;
                for (let i = 0; i < magicCount; i++) {
                    const rarity = rollLootRarity(hasEncounter, isBoss);
                    loot.items.push(pickMagicItem(rarity, potionChance));
                }
            }

            return loot;
        }

        function ensureRoomLoot(room) {
            if (!room.loot) {
                room.loot = generateLoot(room);
                return true;
            }
            return false;
        }

        function formatLootSummary(loot) {
            if (!loot) return "No notable loot";
            const parts = [];
            if (loot.coins) {
                parts.push(`Coins: ${formatCoins(loot.coins)}`);
            }
            if (loot.items && loot.items.length > 0) {
                const names = loot.items.map(item => item.name);
                const shown = names.slice(0, 3).join(', ');
                const extra = names.length > 3 ? ` +${names.length - 3} more` : '';
                parts.push(`Items: ${shown}${extra}`);
            }
            return parts.length > 0 ? parts.join(' â€¢ ') : "No notable loot";
        }

        function getLootRevealThreshold(room) {
            if (room.lootRevealThreshold) return room.lootRevealThreshold;
            // Success threshold is always +3 or +4 (never 2, 5, or 6)
            room.lootRevealThreshold = Math.random() < 0.5 ? 3 : 4;
            saveDungeonState();
            return room.lootRevealThreshold;
        }

        // Assign hidden level to an item (0 = visible, 1-4 = hidden at that success level)
        function assignItemHiddenLevel(item) {
            // Check if it's a magic item
            if (item.category === 'Magic') {
                // Potions are hidden at 2-3 successes
                if (item.name && item.name.toLowerCase().includes('potion')) {
                    return Math.random() < 0.3 ? 0 : randInt(2, 3); // 30% visible, otherwise 2-3
                }
                // Rare or Legendary non-potion magic items hidden at 4 successes
                if (item.rarity === 'Rare' || item.rarity === 'Legendary') {
                    return 4;
                }
                // Common magic items hidden at 2-3 successes
                return randInt(2, 3);
            }
            // Coins - mostly visible or low hidden level
            if (item.category === 'Coins') {
                return Math.random() < 0.5 ? 0 : randInt(1, 2); // 50% visible, otherwise 1-2
            }
            // Mundane items - often visible
            if (item.category === 'Mundane') {
                return Math.random() < 0.4 ? 0 : randInt(1, 2); // 40% visible, otherwise 1-2
            }
            // Trinkets and Gemstones - sometimes visible, otherwise 2-3
            if (item.category === 'Trinket' || item.category === 'Gemstone') {
                return Math.random() < 0.25 ? 0 : randInt(2, 3); // 25% visible, otherwise 2-3
            }
            // Default: hidden at 2-3
            return randInt(2, 3);
        }

        // Ensure all items in room have hidden levels assigned
        function ensureRoomHiddenLevels(room) {
            if (!room.loot) return false;
            let updated = false;

            // Assign hidden level to coins
            if (room.loot.coins && room.loot.coins.hiddenLevel === undefined) {
                room.loot.coins.hiddenLevel = assignItemHiddenLevel({ category: 'Coins' });
                updated = true;
            }

            // Assign hidden levels to items
            if (room.loot.items) {
                room.loot.items.forEach(item => {
                    if (item.hiddenLevel === undefined) {
                        item.hiddenLevel = assignItemHiddenLevel(item);
                        updated = true;
                    }
                });
            }

            // Initialize the room's revealed success level (how many successes have been achieved)
            if (room.revealedSuccessLevel === undefined) {
                room.revealedSuccessLevel = 0;
                updated = true;
            }

            return updated;
        }

        function getLootRevealRequirement(room, tierKey) {
            const config = getLootRevealTiers()[tierKey];
            if (!config) return null;
            let created = false;
            if (!room.lootReveal) {
                room.lootReveal = {};
                created = true;
            }
            if (!room.lootReveal[tierKey]) {
                room.lootReveal[tierKey] = {
                    threshold: getLootRevealThreshold(room),
                    successes: config.successes,
                    revealed: false
                };
                created = true;
            }
            if (room.lootReveal[tierKey].concealment === undefined) {
                room.lootReveal[tierKey].concealment = room.lootReveal[tierKey].threshold + randInt(0, 2);
                created = true;
            }
            if (created) {
                saveDungeonState();
            }
            return room.lootReveal[tierKey];
        }

        function getHiddenRevealMap(room) {
            if (!room.hiddenReveal) {
                room.hiddenReveal = {};
            }
            return room.hiddenReveal;
        }

        function getHiddenRequirement(room, hiddenId, { threshold, successes }) {
            const hiddenReveal = getHiddenRevealMap(room);
            let created = false;
            if (!hiddenReveal[hiddenId]) {
                hiddenReveal[hiddenId] = {
                    threshold,
                    successes,
                    revealed: false,
                    resolved: false,
                    concealment: threshold + randInt(0, 2)
                };
                created = true;
            }
            if (hiddenReveal[hiddenId].concealment === undefined) {
                hiddenReveal[hiddenId].concealment = hiddenReveal[hiddenId].threshold + randInt(0, 2);
                created = true;
            }
            if (created) {
                saveDungeonState();
            }
            return hiddenReveal[hiddenId];
        }

        function buildHiddenTierHtml({ id, requirement, contentHtml, isLoot }) {
            if (!requirement) return contentHtml;
            const revealedClass = requirement.revealed ? 'revealed' : '';
            const dataAttr = isLoot
                ? `data-tier="${id}" data-hidden-type="loot"`
                : `data-hidden-id="${id}" data-hidden-type="danger"`;
            return `
                <div class="hidden-tier ${revealedClass}">
                    <div class="hidden-cover">
                        <button class="hidden-discover" ${dataAttr}>
                            <span class="hidden-discover-title">Search to reveal:</span>
                            <span class="hidden-discover-detail">${requirement.successes} Successes at Threshold +${requirement.threshold}</span>
                        </button>
                    </div>
                    <div class="hidden-content">
                        ${contentHtml}
                    </div>
                </div>
            `;
        }

        function isAmbusherThreat(threat) {
            return (threat.abilities || []).some(ability => ability.toLowerCase().startsWith('ambusher'));
        }

        function isHiddenThreat(threat) {
            if (isAmbusherThreat(threat)) return true;
            if (threat.isHazard) {
                return (threat.threshold ?? 0) >= 3;
            }
            return false;
        }

        function buildThreatBlockHtml(threat, index) {
            const bossClass = threat.isBoss ? 'boss' : '';
            const resolvedClass = threat.resolved ? 'resolved' : '';
            const abilitiesHtml = threat.abilities.length > 0
                ? threat.abilities.map(a => `<div class="ability">â€¢ <span class="ability-name">${a}</span></div>`).join('')
                : '<div class="ability">â€”</div>';

            const resolutionHtml = threat.checkRequirement
                ? `<div class="threat-stat"><span class="stat-label">Check:</span> ${threat.checkRequirement}</div>`
                : `<div class="threat-stat"><span class="stat-label">Defeat/Overwhelm:</span> ${threat.defeat}/${threat.overwhelm}</div>`;
            const rangeValue = threat.range ?? 'Melee';
            const title = `${threat.isBoss ? 'ðŸ‘‘ BOSS: ' : ''}${threat.keyword} ${threat.type} x${threat.quantity}`;

            return `
                <div class="threat-block ${bossClass} ${resolvedClass}">
                    <div class="threat-header">
                        <span>${title}</span>
                        <label class="resolve-toggle">
                            <input type="checkbox" class="threat-resolve-toggle" data-threat-index="${index}" ${threat.resolved ? 'checked' : ''}>
                            Resolved
                        </label>
                    </div>
                    <div class="threat-stats">
                        <div class="threat-stat"><span class="stat-label">Damage:</span> ${threat.damage}d6</div>
                        <div class="threat-stat"><span class="stat-label">Threshold:</span> +${threat.threshold}</div>
                        ${resolutionHtml}
                        <div class="threat-stat"><span class="stat-label">Range:</span> ${rangeValue}</div>
                    </div>
                    <div class="threat-abilities">
                        <div class="ability" style="color: var(--text-muted); margin-bottom: 0.25rem;">Abilities:</div>
                        ${abilitiesHtml}
                    </div>
                </div>
            `;
        }

        function buildDoorTrapHtml({ id, direction, door, requirement }) {
            const trapDamageHtml = door.trapDamage
                ? `<div class="hidden-danger-detail">Trap Damage: ${door.trapDamage}d6</div>`
                : '';
            const bypassHtml = door.bypass
                ? `<div class="hidden-danger-detail">Bypass: <span class="potency-${door.bypass.potency.toLowerCase()}">${door.bypass.potency}</span> check to ${door.bypass.verb}, Threshold +${door.bypass.threshold}</div>`
                : '';
            const resolvedClass = requirement.resolved ? 'resolved' : '';

            return `
                <div class="hidden-danger-block ${resolvedClass}">
                    <div class="hidden-danger-title">
                        <span>${direction} Door Trap</span>
                        <label class="resolve-toggle">
                            <input type="checkbox" class="hidden-resolve-toggle" data-hidden-id="${id}" ${requirement.resolved ? 'checked' : ''}>
                            Resolved
                        </label>
                    </div>
                    ${bypassHtml}
                    ${trapDamageHtml}
                </div>
            `;
        }

        function attachResolutionHandlers(room, scope) {
            if (!scope) return;
            scope.querySelectorAll('.threat-resolve-toggle').forEach(toggle => {
                toggle.addEventListener('change', () => {
                    const index = Number(toggle.dataset.threatIndex);
                    const threat = room.threats?.[index];
                    if (!threat) return;
                    threat.resolved = toggle.checked;
                    saveDungeonState();
                    const block = toggle.closest('.threat-block');
                    if (block) {
                        block.classList.toggle('resolved', toggle.checked);
                    }
                });
            });

            scope.querySelectorAll('.hidden-resolve-toggle').forEach(toggle => {
                toggle.addEventListener('change', () => {
                    const hiddenId = toggle.dataset.hiddenId;
                    if (!hiddenId) return;
                    const hiddenReveal = getHiddenRevealMap(room);
                    if (!hiddenReveal[hiddenId]) return;
                    hiddenReveal[hiddenId].resolved = toggle.checked;
                    saveDungeonState();
                    const block = toggle.closest('.hidden-danger-block');
                    if (block) {
                        block.classList.toggle('resolved', toggle.checked);
                    }
                });
            });
        }

        // ==================== ROOM GENERATION ====================
        function generateRoom({ position, moveDir, fromRoom }) {
            const roomIndex = dungeonState.rooms.length + 1;
            const profile = gameData.difficultyProfiles[dungeonState.difficulty];
            const isEntrance = roomIndex === 1;
            const rotation = isEntrance
                ? randomRotation()
                : (moveDir ? getRotationForMove(moveDir) : 0);
            const remainingAfter = dungeonState.totalRooms - (dungeonState.rooms.length + 1);
            const frontierBefore = getFrontierCount();
            const usedExit = fromRoom && moveDir ? 1 : 0;
            const guaranteedFrontier = frontierBefore - usedExit;
            const minExits = isEntrance
                ? 1
                : (remainingAfter > 0 && guaranteedFrontier === 0 ? 1 : 0);
            const includeDeadEnds = !isEntrance && remainingAfter > 0 && guaranteedFrontier > 0;
            const neighborConstraints = getNeighborExitConstraints(position);

            let layoutSelection = null;
            let attempts = 0;
            while (!layoutSelection && attempts < 20) {
                if (isEntrance) {
                    const entranceIds = Object.keys(gameData.entranceLayouts || {});
                    const entranceId = pick(entranceIds);
                    const exits = gameData.entranceLayouts[entranceId] || [];
                    const mapExits = rotateExits(exits, rotation);
                    const availableExits = getAvailableExpansionDirections(position, mapExits);
                    if (remainingAfter === 0 || availableExits.length > 0) {
                        layoutSelection = {
                            bucket: "Entrance",
                            layoutId: entranceId,
                            exits,
                            mapExits
                        };
                    }
                } else {
                    const candidate = selectLayout({ isBossRoom: false, minExits, includeDeadEnds });
                    const exits = getExitsForLayout(candidate.layoutId);
                    const mapExits = rotateExits(exits, rotation);
                    if (!layoutMatchesConstraints(mapExits, neighborConstraints)) {
                        attempts += 1;
                        continue;
                    }
                    const availableExits = getAvailableExpansionDirections(position, mapExits);
                    const frontierAfter = guaranteedFrontier + availableExits.length;
                    if (remainingAfter === 0 || frontierAfter > 0) {
                        layoutSelection = { ...candidate, exits, mapExits };
                    }
                }
                attempts += 1;
            }

            if (!layoutSelection && !isEntrance) {
                // Fallback: only allow dead ends if there's an alternative path (guaranteed frontier > 0)
                // Otherwise, require at least one expansion exit to prevent premature dungeon end
                const fallbackDeadEnds = guaranteedFrontier > 0;
                const fallbackMinExits = fallbackDeadEnds ? 0 : 1;
                const fallback = selectLayout({ isBossRoom: false, minExits: fallbackMinExits, includeDeadEnds: fallbackDeadEnds });
                const fallbackExits = getExitsForLayout(fallback.layoutId);
                const fallbackMapExits = rotateExits(fallbackExits, rotation);
                layoutSelection = {
                    ...fallback,
                    exits: fallbackExits,
                    mapExits: fallbackMapExits
                };
            }

            if (!layoutSelection && isEntrance) {
                const entranceIds = Object.keys(gameData.entranceLayouts || {});
                const entranceId = entranceIds[0] || "ENT_E";
                const exits = gameData.entranceLayouts[entranceId] || [];
                layoutSelection = {
                    bucket: "Entrance",
                    layoutId: entranceId,
                    exits,
                    mapExits: rotateExits(exits, rotation)
                };
            }

            layoutSelection.mapExits = applyExitConstraints(layoutSelection.mapExits, neighborConstraints);
            const description = generateDescription();
            const doors = {};
            layoutSelection.mapExits.forEach(exit => {
                doors[exit] = generateDoor(profile);
            });
            if (fromRoom && moveDir) {
                const entryDir = getOppositeDirection(moveDir);
                if (!fromRoom.doors) {
                    fromRoom.doors = {};
                }
                const linkedDoor = fromRoom.doors[moveDir] || { status: 'Open', bypass: null };
                fromRoom.doors[moveDir] = linkedDoor;
                doors[entryDir] = linkedDoor;
            }

            const room = {
                id: `room_${Date.now()}_${roomIndex}`,
                index: roomIndex,
                isBoss: roomIndex === dungeonState.totalRooms,
                bucket: layoutSelection.bucket,
                layoutId: layoutSelection.layoutId,
                pngPath: `png/${layoutSelection.bucket.toLowerCase().replace(' ', '-')}/${layoutSelection.layoutId}.png`,
                exits: layoutSelection.mapExits,
                baseExits: layoutSelection.exits,
                doors,
                rotation,
                position,
                entryDir: moveDir ? getOppositeDirection(moveDir) : null,
                description: description.text,
                threats: generateThreats(roomIndex === dungeonState.totalRooms),
                loot: null,
                timestamp: Date.now()
            };

            room.loot = generateLoot(room);

            dungeonState.rooms.push(room);
            dungeonState.map[coordKey(position.x, position.y)] = room.id;
            linkAdjacentDoors(room);
            saveDungeonState();

            return room;
        }

        function assignBossRoom() {
            if (!dungeonState || dungeonState.rooms.length === 0) return;
            const bossRoom = dungeonState.rooms.find(room => room.index === dungeonState.totalRooms);
            dungeonState.rooms.forEach(room => {
                const shouldBeBoss = bossRoom ? room.id === bossRoom.id : false;
                const wasBoss = room.isBoss;
                if (shouldBeBoss && !room.isBoss) {
                    room.threats = generateThreats(true);
                }
                if (!shouldBeBoss && room.isBoss) {
                    room.threats = generateThreats(false);
                }
                room.isBoss = shouldBeBoss;
                if (wasBoss !== room.isBoss) {
                    room.loot = generateLoot(room);
                }
            });
            dungeonState.bossRoomId = bossRoom ? bossRoom.id : null;
            saveDungeonState();
        }

        // ==================== RENDERING ====================
        function renderRoom(room) {
            document.getElementById('emptyState').classList.add('hidden');
            document.getElementById('roomContent').classList.remove('hidden');

            const lootUpdated = ensureRoomLoot(room);
            if (lootUpdated) {
                saveDungeonState();
            }
            
            const displayExits = [...room.exits];
            if (room.entryDir && !displayExits.includes(room.entryDir)) {
                displayExits.push(room.entryDir);
            }
            getLinkedNeighborDirections(room).forEach(dir => {
                if (!displayExits.includes(dir)) {
                    displayExits.push(dir);
                }
            });

            let exitsHtml = '';
            if (displayExits.length === 0) {
                exitsHtml = '<div class="no-threats">No exits â€” Dead End. Retrace your steps.</div>';
            } else {
                exitsHtml = '<div class="exit-list">';
                displayExits.forEach(exit => {
                    const baseDoor = room.doors[exit] || { status: 'Open' };
                    const door = baseDoor;
                    const isTrapped = door.status === 'Trapped';
                    const displayStatus = isTrapped ? 'Open' : door.status;
                    const statusClass = displayStatus === 'Open' ? 'open' : 'blocked';
                    let bypassHtml = '';
                    if (door.bypass && !isTrapped) {
                        bypassHtml = `<div class="bypass-info">
                            Bypass: <span class="potency-${door.bypass.potency.toLowerCase()}">${door.bypass.potency}</span>
                            check to ${door.bypass.verb}, Threshold +${door.bypass.threshold}
                        </div>`;
                    }
                    const vec = directionVectors[exit];
                    const targetPos = { x: room.position.x + vec.x, y: room.position.y + vec.y };
                    const targetRoom = getRoomByPosition(targetPos);
                    const oppositeDir = getOppositeDirection(exit);
                    const canLink = targetRoom
                        ? roomHasExit(room, exit) && roomHasExit(targetRoom, oppositeDir)
                        : true;
                    const canCreate = (!!targetRoom && canLink) || (!targetRoom && dungeonState.rooms.length < dungeonState.totalRooms);
                    const isReturn = Boolean(targetRoom);
                    const buttonLabel = isReturn ? 'Return' : 'Go this way';
                    exitsHtml += `
                        <div class="exit-item">
                            <span class="exit-direction">${directionLabels[exit]}</span>
                            <span class="exit-status ${statusClass}">${displayStatus}</span>
                            <div class="exit-actions">
                                <button class="exit-action" data-dir="${exit}" data-return="${isReturn}" ${canCreate ? '' : 'disabled'}>${buttonLabel}</button>
                            </div>
                            ${bypassHtml}
                        </div>
                    `;
                });
                exitsHtml += '</div>';
            }
            
            let threatsHtml = '';
            const hasVisibleThreats = room.threats.some(threat => !isHiddenThreat(threat));
            if (!hasVisibleThreats) {
                threatsHtml = '<div class="no-threats">The room appears empty of immediate threats.</div>';
            } else {
                threatsHtml = '<div class="threat-list">';
                room.threats.forEach((threat, index) => {
                    if (isHiddenThreat(threat)) return;
                    threatsHtml += buildThreatBlockHtml(threat, index);
                });
                threatsHtml += '</div>';
            }

            // Ensure hidden levels are assigned to all loot items
            const hiddenLevelsUpdated = ensureRoomHiddenLevels(room);
            if (hiddenLevelsUpdated) {
                saveDungeonState();
            }

            const loot = room.loot;
            const threshold = getLootRevealThreshold(room);
            const revealedLevel = room.revealedSuccessLevel || 0;

            // Helper to render an item with its hidden level
            function renderLootItem(item, index = 0) {
                const isRevealed = item.hiddenLevel === 0 || item.hiddenLevel <= revealedLevel;
                const revealClass = isRevealed ? 'revealed' : '';

                if (item.category === 'Magic') {
                    return `
                        <div class="hidden-item-entry ${revealClass}" data-hidden-level="${item.hiddenLevel}">
                            <div class="hidden-item">
                                <span class="hidden-tag ${item.rarity.toLowerCase()}">${item.rarity}</span>
                                <span>${item.name}</span>
                            </div>
                        </div>
                    `;
                } else {
                    return `
                        <div class="hidden-item-entry ${revealClass}" data-hidden-level="${item.hiddenLevel}">
                            <div class="hidden-item">${item.name}</div>
                        </div>
                    `;
                }
            }

            // Build visible loot section (hiddenLevel = 0)
            let visibleLootHtml = '';
            if (loot) {
                const visibleItems = [];

                if (loot.coins && loot.coins.hiddenLevel === 0) {
                    visibleItems.push(`<div class="hidden-item">${formatCoins(loot.coins)}</div>`);
                }

                (loot.items || []).forEach(item => {
                    if (item.hiddenLevel === 0) {
                        if (item.category === 'Magic') {
                            const itemDesc = gameData.magicItemDescriptions && gameData.magicItemDescriptions[item.name];
                            const tooltipHtml = itemDesc
                                ? `<span class="tooltip-container loot-tooltip"><span class="tooltip-icon">?</span><span class="tooltip-text">${itemDesc}</span></span>`
                                : '';
                            visibleItems.push(`
                                <div class="hidden-item">
                                    <span class="hidden-tag ${item.rarity.toLowerCase()}">${item.rarity}</span>
                                    <span>${item.name}</span>${tooltipHtml}
                                </div>
                            `);
                        } else {
                            visibleItems.push(`<div class="hidden-item">${item.name}</div>`);
                        }
                    }
                });

                if (visibleItems.length > 0) {
                    visibleLootHtml = `
                        <div class="visible-loot">
                            <div class="visible-loot-title">Visible Loot</div>
                            <div class="hidden-block">
                                <div class="hidden-items">
                                    ${visibleItems.join('')}
                                </div>
                            </div>
                        </div>
                    `;
                }
            }

            // Build hidden section header with threshold and tick boxes
            const hiddenHeaderHtml = `
                <div class="hidden-header">
                    <div class="hidden-threshold">
                        Search Threshold: <span class="hidden-threshold-value">+${threshold}</span>
                    </div>
                    <div class="hidden-successes">
                        <span class="hidden-successes-label">Successes:</span>
                        <div class="success-checkboxes">
                            ${[1, 2, 3, 4].map(level => `
                                <div class="success-box">
                                    <input type="checkbox" class="success-checkbox" data-level="${level}" ${level <= revealedLevel ? 'checked' : ''}>
                                    <span class="success-checkbox-label">${level}</span>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                </div>
            `;

            // Build hidden items list (items with hiddenLevel > 0)
            let hiddenItemsHtml = '';
            if (loot) {
                const hiddenItemsList = [];

                // Coins
                if (loot.coins && loot.coins.hiddenLevel > 0) {
                    const isRevealed = loot.coins.hiddenLevel <= revealedLevel;
                    hiddenItemsList.push({
                        level: loot.coins.hiddenLevel,
                        html: `
                            <div class="hidden-item-entry ${isRevealed ? 'revealed' : ''}" data-hidden-level="${loot.coins.hiddenLevel}">
                                <div class="hidden-block">
                                    <h4>Coins</h4>
                                    <div class="hidden-items">
                                        <div class="hidden-item">${formatCoins(loot.coins)}</div>
                                    </div>
                                </div>
                            </div>
                        `
                    });
                }

                // Group items by category
                const magicItems = (loot.items || []).filter(item => item.category === 'Magic' && item.hiddenLevel > 0);
                const mundaneItems = (loot.items || []).filter(item => item.category === 'Mundane' && item.hiddenLevel > 0);
                const curios = (loot.items || []).filter(item => ['Trinket', 'Gemstone'].includes(item.category) && item.hiddenLevel > 0);

                // Magic items grouped by rarity
                const magicByRarity = {
                    Common: magicItems.filter(item => item.rarity === 'Common'),
                    Rare: magicItems.filter(item => item.rarity === 'Rare'),
                    Legendary: magicItems.filter(item => item.rarity === 'Legendary')
                };

                Object.entries(magicByRarity).forEach(([rarity, items]) => {
                    items.forEach(item => {
                        const isRevealed = item.hiddenLevel <= revealedLevel;
                        const itemDesc = gameData.magicItemDescriptions && gameData.magicItemDescriptions[item.name];
                        const tooltipHtml = itemDesc
                            ? `<span class="tooltip-container loot-tooltip"><span class="tooltip-icon">?</span><span class="tooltip-text">${itemDesc}</span></span>`
                            : '';
                        hiddenItemsList.push({
                            level: item.hiddenLevel,
                            html: `
                                <div class="hidden-item-entry ${isRevealed ? 'revealed' : ''}" data-hidden-level="${item.hiddenLevel}">
                                    <div class="hidden-block">
                                        <h4>${rarity} Magic</h4>
                                        <div class="hidden-items">
                                            <div class="hidden-item">
                                                <span class="hidden-tag ${item.rarity.toLowerCase()}">${item.rarity}</span>
                                                <span>${item.name}</span>${tooltipHtml}
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            `
                        });
                    });
                });

                // Mundane items (each individually)
                mundaneItems.forEach(item => {
                    const isRevealed = item.hiddenLevel <= revealedLevel;
                    hiddenItemsList.push({
                        level: item.hiddenLevel,
                        html: `
                            <div class="hidden-item-entry ${isRevealed ? 'revealed' : ''}" data-hidden-level="${item.hiddenLevel}">
                                <div class="hidden-block">
                                    <h4>Supplies</h4>
                                    <div class="hidden-items">
                                        <div class="hidden-item">${item.name}</div>
                                    </div>
                                </div>
                            </div>
                        `
                    });
                });

                // Curios (each individually)
                curios.forEach(item => {
                    const isRevealed = item.hiddenLevel <= revealedLevel;
                    const label = item.category === 'Gemstone' ? 'Gemstone' : 'Trinket';
                    hiddenItemsList.push({
                        level: item.hiddenLevel,
                        html: `
                            <div class="hidden-item-entry ${isRevealed ? 'revealed' : ''}" data-hidden-level="${item.hiddenLevel}">
                                <div class="hidden-block">
                                    <h4>${label}</h4>
                                    <div class="hidden-items">
                                        <div class="hidden-item">${item.name}</div>
                                    </div>
                                </div>
                            </div>
                        `
                    });
                });

                // Hidden threats (ambushers)
                room.threats.forEach((threat, index) => {
                    if (!isHiddenThreat(threat)) return;
                    const hiddenId = `threat-${index}`;
                    const requirement = getHiddenRequirement(room, hiddenId, { threshold: threat.threshold, successes: 2 });
                    const threatHiddenLevel = requirement.successes || 2;
                    const isRevealed = threatHiddenLevel <= revealedLevel || requirement.revealed;
                    hiddenItemsList.push({
                        level: threatHiddenLevel,
                        html: `
                            <div class="hidden-item-entry ${isRevealed ? 'revealed' : ''}" data-hidden-level="${threatHiddenLevel}" data-hidden-id="${hiddenId}">
                                ${buildThreatBlockHtml(threat, index)}
                            </div>
                        `
                    });
                });

                // Trapped doors
                Object.entries(room.doors || {}).forEach(([direction, door]) => {
                    if (door.status !== 'Trapped') return;
                    const hiddenId = `door-trap-${direction}`;
                    const requirement = getHiddenRequirement(room, hiddenId, { threshold, successes: 1 });
                    const trapHiddenLevel = requirement.successes || 1;
                    const isRevealed = trapHiddenLevel <= revealedLevel || requirement.revealed;
                    hiddenItemsList.push({
                        level: trapHiddenLevel,
                        html: `
                            <div class="hidden-item-entry ${isRevealed ? 'revealed' : ''}" data-hidden-level="${trapHiddenLevel}" data-hidden-id="${hiddenId}">
                                ${buildDoorTrapHtml({
                                    id: hiddenId,
                                    direction: directionLabels[direction] || direction,
                                    door,
                                    requirement
                                })}
                            </div>
                        `
                    });
                });

                // Sort by level
                hiddenItemsList.sort((a, b) => a.level - b.level);
                hiddenItemsHtml = hiddenItemsList.map(item => item.html).join('');
            }

            const hiddenHtml = `
                ${visibleLootHtml}
                ${hiddenHeaderHtml}
                <div class="hidden-list">
                    ${hiddenItemsHtml || '<div class="no-threats" style="display: block;">Search to discover what may be hidden here.</div>'}
                </div>
            `;
            
            document.getElementById('roomContent').innerHTML = `
                <div class="room-header">
                    <span class="room-number">Room ${room.index} of ${dungeonState.totalRooms}</span>
                    ${room.isBoss ? '<span class="room-badge">BOSS ROOM</span>' : ''}
                </div>
                <div class="room-body">
                    <div class="room-meta">
                        <div class="meta-item">
                            <span class="meta-label">Layout Type</span>
                            <span class="meta-value">${room.bucket}</span>
                        </div>
                        <div class="meta-item">
                            <span class="meta-label">Layout ID</span>
                            <span class="meta-value">${room.layoutId}</span>
                        </div>
                        <div class="meta-item">
                            <span class="meta-label">PNG Path</span>
                            <span class="meta-value">${room.pngPath}</span>
                        </div>
                        <div class="meta-item">
                            <span class="meta-label">Grid Position</span>
                            <span class="meta-value">(${room.position.x}, ${room.position.y})</span>
                        </div>
                        <div class="meta-item">
                            <span class="meta-label">Exits</span>
                            <span class="meta-value">${room.exits.length > 0 ? room.exits.join(', ') : 'None'}</span>
                        </div>
                    </div>
                    
                    <div class="room-description">${room.description}</div>
                    
                    <div class="exits">
                        <div class="section-title">Exits & Doors</div>
                        ${exitsHtml}
                    </div>
                    
                    <div class="threats">
                        <div class="section-title">Threats</div>
                        ${threatsHtml}
                    </div>

                    <div class="hidden-section">
                        <div class="section-title">Hidden</div>
                        ${hiddenHtml}
                    </div>
                </div>
            `;
            
            document.querySelectorAll('.exit-action').forEach(button => {
                button.addEventListener('click', () => {
                    const direction = button.dataset.dir;
                    const isReturn = button.dataset.return === 'true';
                    handleExitMove(direction, { isReturn });
                });
            });

            // Handle success checkbox changes
            document.querySelectorAll('.success-checkbox').forEach(checkbox => {
                checkbox.addEventListener('change', () => {
                    const level = parseInt(checkbox.dataset.level);

                    // If checking a box, also check all lower levels
                    // If unchecking, also uncheck all higher levels
                    document.querySelectorAll('.success-checkbox').forEach(cb => {
                        const cbLevel = parseInt(cb.dataset.level);
                        if (checkbox.checked) {
                            if (cbLevel <= level) cb.checked = true;
                        } else {
                            if (cbLevel >= level) cb.checked = false;
                        }
                    });

                    // Calculate new revealed level (highest checked box)
                    let newRevealedLevel = 0;
                    document.querySelectorAll('.success-checkbox:checked').forEach(cb => {
                        const cbLevel = parseInt(cb.dataset.level);
                        if (cbLevel > newRevealedLevel) newRevealedLevel = cbLevel;
                    });

                    // Update room state
                    room.revealedSuccessLevel = newRevealedLevel;
                    saveDungeonState();

                    // Reveal/hide items based on new level
                    document.querySelectorAll('.hidden-item-entry').forEach(entry => {
                        const itemLevel = parseInt(entry.dataset.hiddenLevel);
                        if (itemLevel <= newRevealedLevel) {
                            entry.classList.add('revealed');
                        } else {
                            entry.classList.remove('revealed');
                        }
                    });

                    // Also mark hidden dangers as revealed in their requirement
                    document.querySelectorAll('.hidden-item-entry[data-hidden-id]').forEach(entry => {
                        const hiddenId = entry.dataset.hiddenId;
                        const itemLevel = parseInt(entry.dataset.hiddenLevel);
                        const requirement = getHiddenRevealMap(room)[hiddenId];
                        if (requirement && itemLevel <= newRevealedLevel) {
                            requirement.revealed = true;
                        }
                    });
                });
            });

            attachResolutionHandlers(room, document.getElementById('roomContent'));
        }

        function renderMap() {
            const mapGrid = document.getElementById('mapGrid');
            const mapRooms = document.getElementById('mapRooms');
            const mapEmpty = document.getElementById('mapEmpty');

            if (!dungeonState || dungeonState.rooms.length === 0) {
                mapGrid.classList.add('hidden');
                mapEmpty.classList.remove('hidden');
                return;
            }

            mapGrid.classList.remove('hidden');
            mapEmpty.classList.add('hidden');

            const positions = dungeonState.rooms.map(room => room.position);
            const minX = Math.min(...positions.map(pos => pos.x));
            const maxX = Math.max(...positions.map(pos => pos.x));
            const minY = Math.min(...positions.map(pos => pos.y));
            const maxY = Math.max(...positions.map(pos => pos.y));

            const roomSize = 140;
            const padding = 70;
            const width = (maxX - minX + 1) * roomSize + padding * 2;
            const height = (maxY - minY + 1) * roomSize + padding * 2;

            mapGrid.style.setProperty('--room-size', `${roomSize}px`);
            mapGrid.style.width = `${Math.max(width, 240)}px`;
            mapGrid.style.height = `${Math.max(height, 240)}px`;
            mapRooms.style.width = `${Math.max(width, 240)}px`;
            mapRooms.style.height = `${Math.max(height, 240)}px`;

            mapRooms.innerHTML = '';
            dungeonState.rooms.forEach(room => {
                const offsetX = (room.position.x - minX) * roomSize + padding;
                const offsetY = (room.position.y - minY) * roomSize + padding;
                const roomDiv = document.createElement('div');
                const isCurrent = room.id === dungeonState.currentRoomId;
                const isStart = room.position.x === 0 && room.position.y === 0;
                const isBoss = room.id === dungeonState.bossRoomId;

                roomDiv.className = `map-room${isCurrent ? ' current' : ''}${isStart ? ' start' : ''}${isBoss ? ' boss' : ''}`;
                roomDiv.style.left = `${offsetX}px`;
                roomDiv.style.top = `${offsetY}px`;

                const img = document.createElement('img');
                img.src = getPngSrc(room.pngPath);
                img.alt = `Room ${room.index}`;
                img.style.transform = `rotate(${room.rotation}deg)`;
                img.addEventListener('error', () => {
                    const normalized = normalizePngPath(room.pngPath);
                    if (!missingPngPaths.has(normalized)) {
                        missingPngPaths.add(normalized);
                        updatePngStatus();
                    }
                });

                const label = document.createElement('div');
                label.className = 'map-room-label';
                label.innerHTML = `${room.isBoss ? 'ðŸ‘‘ ' : ''}<span>Room ${room.index}</span>`;

                roomDiv.appendChild(img);
                roomDiv.appendChild(label);
                mapRooms.appendChild(roomDiv);
            });
        }

        function getHiddenDangers(room, { onlyUnrevealed = false } = {}) {
            const dangers = [];
            room.threats.forEach((threat, index) => {
                if (!isHiddenThreat(threat)) return;
                const hiddenId = `threat-${index}`;
                const requirement = getHiddenRequirement(room, hiddenId, { threshold: threat.threshold, successes: 1 });
                if (onlyUnrevealed && requirement.revealed) return;
                const label = isAmbusherThreat(threat) ? 'Ambush' : 'Trap';
                dangers.push({
                    id: hiddenId,
                    label,
                    requirement,
                    html: buildThreatBlockHtml(threat, index)
                });
            });

            Object.entries(room.doors || {}).forEach(([direction, door]) => {
                if (door.status !== 'Trapped') return;
                const hiddenId = `door-trap-${direction}`;
                const threshold = door.bypass?.threshold ?? getLootRevealThreshold(room);
                const requirement = getHiddenRequirement(room, hiddenId, { threshold, successes: 1 });
                if (onlyUnrevealed && requirement.revealed) return;
                dangers.push({
                    id: hiddenId,
                    label: 'Trap',
                    requirement,
                    html: buildDoorTrapHtml({
                        id: hiddenId,
                        direction: directionLabels[direction] || direction,
                        door,
                        requirement
                    })
                });
            });

            return dangers;
        }

        function showDangerRevealModal(room, dangers) {
            const modal = document.getElementById('dangerRevealModal');
            const title = document.getElementById('dangerRevealTitle');
            const intro = document.getElementById('dangerRevealIntro');
            const list = document.getElementById('dangerRevealList');
            const labels = Array.from(new Set(dangers.map(danger => danger.label)));
            const titleText = labels.length === 1 ? labels[0] : 'Hidden Dangers';

            title.textContent = titleText;
            intro.textContent = 'Hidden dangers surface as you attempt to move on.';
            list.innerHTML = dangers.map(danger => danger.html).join('');
            modal.classList.remove('hidden');
            attachResolutionHandlers(room, modal);
        }

        function handleExitMove(direction, { isReturn = false } = {}) {
            if (!dungeonState) return;
            const currentRoom = getCurrentRoom();
            if (!currentRoom) return;
            if (!isReturn) {
                const hiddenDangers = getHiddenDangers(currentRoom, { onlyUnrevealed: true });
                if (hiddenDangers.length > 0) {
                    hiddenDangers.forEach(danger => {
                        danger.requirement.revealed = true;
                    });
                    saveDungeonState();
                    renderRoom(currentRoom);
                    showDangerRevealModal(currentRoom, hiddenDangers);
                    return;
                }
            }
            const vec = directionVectors[direction];
            const nextPos = { x: currentRoom.position.x + vec.x, y: currentRoom.position.y + vec.y };
            const existingRoom = getRoomByPosition(nextPos);

            if (existingRoom) {
                const oppositeDir = getOppositeDirection(direction);
                if (!roomHasExit(currentRoom, direction) || !roomHasExit(existingRoom, oppositeDir)) {
                    return;
                }
                syncDoorPair(currentRoom, direction, existingRoom);
                // Mark door as permanently open after passing through
                const door = currentRoom.doors[direction];
                if (door && door.status !== 'Open') {
                    door.status = 'Open';
                    door.bypass = null;
                }
                dungeonState.currentRoomId = existingRoom.id;
                renderRoom(existingRoom);
                renderMap();
                updateButtons();
                saveDungeonState();
                return;
            }

            if (dungeonState.rooms.length >= dungeonState.totalRooms) {
                return;
            }

            const newRoom = generateRoom({ position: nextPos, moveDir: direction, fromRoom: currentRoom });
            // Mark the door as open since we just passed through it
            const door = currentRoom.doors[direction];
            if (door && door.status !== 'Open') {
                door.status = 'Open';
                door.bypass = null;
            }
            dungeonState.currentRoomId = newRoom.id;
            if (newRoom.isBoss) {
                dungeonState.bossRoomId = newRoom.id;
            }

            renderRoom(newRoom);
            renderMap();
            updateButtons();
        }

        function updateButtons() {
            const hasState = dungeonState !== null;
            document.getElementById('exportBtn').disabled = !hasState || dungeonState.rooms.length === 0;
        }

        // ==================== PERSISTENCE ====================
        function saveDungeonState() {
            localStorage.setItem('striveDungeon', JSON.stringify(dungeonState));
            localStorage.setItem('striveUsedLayouts', JSON.stringify(usedLayouts));
        }

        function loadDungeonState() {
            if (!gameData) {
                return;
            }
            const saved = localStorage.getItem('striveDungeon');
            const savedLayouts = localStorage.getItem('striveUsedLayouts');
            
            if (saved) {
                dungeonState = JSON.parse(saved);
                usedLayouts = savedLayouts ? JSON.parse(savedLayouts) : { Rooms: [], Halls: [], "Dead Ends": [] };

                if (!dungeonState.map || dungeonState.rooms.some(room => !room.position)) {
                    localStorage.removeItem('striveDungeon');
                    localStorage.removeItem('striveUsedLayouts');
                    dungeonState = null;
                    usedLayouts = { Rooms: [], Halls: [], "Dead Ends": [] };
                    return;
                }

                if (!dungeonState.currentRoomId && dungeonState.rooms.length > 0) {
                    dungeonState.currentRoomId = dungeonState.rooms[dungeonState.rooms.length - 1].id;
                }
                
                if (dungeonState.rooms.length > 0) {
                    if (!dungeonState.bossRoomId) {
                        assignBossRoom();
                    }
                    renderRoom(getCurrentRoom());
                }
                renderMap();
                updateButtons();
                
                // Restore UI values
                document.getElementById('difficulty').value = dungeonState.difficulty;
                document.getElementById('dungeonLength').value = dungeonState.totalRooms;

                // Restore keywords and abilities
                if (dungeonState.keywords && dungeonState.keywords.length > 0) {
                    const kw1 = dungeonState.keywords[0];
                    document.getElementById('threatKeyword1').value = kw1.name || '';
                    if (kw1.abilities) {
                        if (kw1.abilities[0]) document.getElementById('keywordAbility1_1').value = kw1.abilities[0];
                        if (kw1.abilities[1]) document.getElementById('keywordAbility1_2').value = kw1.abilities[1];
                        if (kw1.abilities[2]) document.getElementById('keywordAbility1_3').value = kw1.abilities[2];
                    }

                    if (dungeonState.keywords.length > 1) {
                        const kw2 = dungeonState.keywords[1];
                        document.getElementById('threatKeyword2').value = kw2.name || '';
                        if (kw2.abilities) {
                            if (kw2.abilities[0]) document.getElementById('keywordAbility2_1').value = kw2.abilities[0];
                            if (kw2.abilities[1]) document.getElementById('keywordAbility2_2').value = kw2.abilities[1];
                            if (kw2.abilities[2]) document.getElementById('keywordAbility2_3').value = kw2.abilities[2];
                        }
                    }
                }

                if (Array.isArray(dungeonState.disallowedThreatTypes)) {
                    setDisallowedThreatTypes(dungeonState.disallowedThreatTypes);
                } else {
                    updateThreatFilterSummary(getDisallowedThreatTypes());
                }

                if (Array.isArray(dungeonState.descriptionThemes)) {
                    setEnabledDescriptionFilters(dungeonState.descriptionThemes);
                } else {
                    setEnabledDescriptionFilters([]);
                }
            }
        }

        // ==================== INITIALIZATION ====================
        function populateAbilityDatalist() {
            const datalist = document.getElementById('abilityList');
            datalist.innerHTML = '';
            if (!gameData || !Array.isArray(gameData.striveAbilities)) {
                return;
            }
            gameData.striveAbilities.forEach(ability => {
                const option = document.createElement('option');
                // Extract just the ability name for the dropdown value
                const abilityName = ability.split(':')[0].trim();
                option.value = abilityName;
                option.textContent = ability;
                datalist.appendChild(option);
            });
        }

        function populateThreatTypeList(selectedTypes = []) {
            const list = document.getElementById('threatTypeList');
            if (!list) return;
            list.innerHTML = '';
            if (!gameData || !Array.isArray(gameData.typeWords)) {
                return;
            }
            gameData.typeWords.forEach(type => {
                const label = document.createElement('label');
                label.className = 'threat-type-item';

                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.value = type;
                checkbox.checked = selectedTypes.includes(type);
                checkbox.addEventListener('change', () => {
                    updateThreatFilterSummary(getDisallowedThreatTypes());
                });

                const text = document.createElement('span');
                text.textContent = type;

                label.appendChild(checkbox);
                label.appendChild(text);

                // Add tooltip with ability description
                const ability = gameData.wordToAbility && gameData.wordToAbility[type];
                if (ability) {
                    const tooltipContainer = document.createElement('span');
                    tooltipContainer.className = 'tooltip-container';

                    const tooltipIcon = document.createElement('span');
                    tooltipIcon.className = 'tooltip-icon';
                    tooltipIcon.textContent = '?';

                    const tooltipText = document.createElement('span');
                    tooltipText.className = 'tooltip-text';
                    // Parse ability name and description
                    const colonIndex = ability.indexOf(':');
                    if (colonIndex > -1) {
                        const abilityName = ability.substring(0, colonIndex);
                        const abilityDesc = ability.substring(colonIndex + 1).trim();
                        tooltipText.innerHTML = `<span class="tooltip-ability-name">${abilityName}</span>${abilityDesc}`;
                    } else {
                        tooltipText.textContent = ability;
                    }

                    tooltipContainer.appendChild(tooltipIcon);
                    tooltipContainer.appendChild(tooltipText);
                    label.appendChild(tooltipContainer);
                }

                list.appendChild(label);
            });
        }

        function getDisallowedThreatTypes() {
            const checkboxes = Array.from(document.querySelectorAll('#threatTypeList input[type="checkbox"]'));
            return checkboxes.filter(box => box.checked).map(box => box.value);
        }

        function setDisallowedThreatTypes(types) {
            const selected = new Set(types || []);
            const checkboxes = Array.from(document.querySelectorAll('#threatTypeList input[type="checkbox"]'));
            checkboxes.forEach(box => {
                box.checked = selected.has(box.value);
            });
            updateThreatFilterSummary(types || []);
        }

        function updateThreatFilterSummary(types) {
            const summary = document.getElementById('threatFilterSummary');
            if (!summary || !gameData || !Array.isArray(gameData.typeWords)) return;
            const count = types.length;
            const total = gameData.typeWords.length;
            summary.textContent = count === 0
                ? 'No disallowed threat types.'
                : `Disallowed ${count} of ${total} threat types.`;
        }

        const descriptionThemeConfig = [
            {
                key: 'cavern',
                label: 'Cavern',
                phrases: ['The stone breathes with deep echoes.', 'Moist rock walls glitter faintly.']
            },
            {
                key: 'dungeon',
                label: 'Dungeon',
                phrases: ['Rusting iron fixtures line the walls.', 'Old mortar and soot stain the stonework.']
            },
            {
                key: 'cold',
                label: 'Cold',
                phrases: ['Frost creeps along the floor.', 'A biting chill cuts through the air.']
            },
            {
                key: 'hot',
                label: 'Hot',
                phrases: ['Heat shimmers across the chamber.', 'The air tastes of ash and embers.']
            },
            {
                key: 'flooded',
                label: 'Flooded',
                phrases: ['Cold water laps at your boots.', 'A stale, briny smell rises from pooled water.']
            },
            {
                key: 'ancient',
                label: 'Ancient',
                phrases: ['Timeworn carvings hint at forgotten empires.', 'Dust clings to every surface like a shroud.']
            },
            {
                key: 'sewer',
                label: 'Sewer',
                phrases: ['The stench is overpowering and wet.', 'Slime coats the stone in sickly streaks.']
            },
            {
                key: 'arcane',
                label: 'Arcane',
                phrases: ['A low hum of magic vibrates in the air.', 'Strange glyphs flicker at the edge of sight.']
            },
            {
                key: 'horror',
                label: 'Horror',
                phrases: ['Shadows stretch a little too far.', 'The silence feels watchful and wrong.']
            }
        ];

        function populateDescriptionFilterList(selectedKeys = []) {
            const list = document.getElementById('descriptionFilterList');
            if (!list) return;
            list.innerHTML = '';
            descriptionThemeConfig.forEach(({ key, label }) => {
                const item = document.createElement('label');
                item.className = 'threat-type-item';

                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.value = key;
                checkbox.checked = selectedKeys.includes(key);
                checkbox.addEventListener('change', () => {
                    updateDescriptionFilterSummary(getEnabledDescriptionFilters());
                });

                const text = document.createElement('span');
                text.textContent = label;

                item.appendChild(checkbox);
                item.appendChild(text);
                list.appendChild(item);
            });
        }

        function getEnabledDescriptionFilters() {
            const checkboxes = Array.from(document.querySelectorAll('#descriptionFilterList input[type="checkbox"]'));
            return checkboxes.filter(box => box.checked).map(box => box.value);
        }

        function setEnabledDescriptionFilters(keys) {
            const selected = new Set(keys || []);
            const checkboxes = Array.from(document.querySelectorAll('#descriptionFilterList input[type="checkbox"]'));
            checkboxes.forEach(box => {
                box.checked = selected.has(box.value);
            });
            updateDescriptionFilterSummary(keys || []);
        }

        function updateDescriptionFilterSummary(keys) {
            const summary = document.getElementById('descriptionFilterSummary');
            if (!summary) return;
            const count = keys.length;
            const total = descriptionThemeConfig.length;
            summary.textContent = count === 0
                ? 'No vibe themes selected.'
                : `Selected ${count} of ${total} vibe themes.`;
        }

        // ==================== EVENT HANDLERS ====================
        initDiceRoller();
        initRestSystem();

        document.getElementById('startBtn').addEventListener('click', () => {
            if (!gameData) {
                document.getElementById('errorDisplay').textContent = 'Dungeon data is not loaded yet.';
                document.getElementById('errorDisplay').classList.remove('hidden');
                return;
            }
            const difficulty = document.getElementById('difficulty').value;
            const totalRooms = parseInt(document.getElementById('dungeonLength').value) || 10;

            // Get keyword 1 and its abilities
            const keyword1 = document.getElementById('threatKeyword1').value.trim() || "Enemy";
            const keyword1Abilities = [
                document.getElementById('keywordAbility1_1').value.trim(),
                document.getElementById('keywordAbility1_2').value.trim(),
                document.getElementById('keywordAbility1_3').value.trim()
            ].filter(a => a);

            // Get keyword 2 and its abilities (optional)
            const keyword2 = document.getElementById('threatKeyword2').value.trim();
            const keyword2Abilities = [
                document.getElementById('keywordAbility2_1').value.trim(),
                document.getElementById('keywordAbility2_2').value.trim(),
                document.getElementById('keywordAbility2_3').value.trim()
            ].filter(a => a);

            const disallowedThreatTypes = getDisallowedThreatTypes();
            const descriptionThemes = getEnabledDescriptionFilters();

            // Reset state
            usedLayouts = { Rooms: [], Halls: [], "Dead Ends": [] };
            dungeonState = {
                difficulty,
                totalRooms: Math.max(6, Math.min(30, totalRooms)),
                keywords: [
                    { name: keyword1, abilities: keyword1Abilities },
                    ...(keyword2 ? [{ name: keyword2, abilities: keyword2Abilities }] : [])
                ],
                disallowedThreatTypes,
                descriptionThemes,
                rooms: [],
                map: {},
                currentRoomId: null,
                bossRoomId: null,
                startedAt: Date.now()
            };

            // Generate first room
            const room = generateRoom({ position: { x: 0, y: 0 }, moveDir: null, fromRoom: null });
            dungeonState.currentRoomId = room.id;
            if (room.isBoss) {
                dungeonState.bossRoomId = room.id;
            }
            renderRoom(room);
            renderMap();
            updateButtons();
        });

        document.getElementById('exportBtn').addEventListener('click', () => {
            if (!dungeonState) return;
            
            const exportData = {
                ...dungeonState,
                exportedAt: Date.now(),
                gameData: gameData
            };
            
            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `dungeon_${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
        });

        document.getElementById('threatFilterBtn').addEventListener('click', () => {
            document.getElementById('threatFilterModal').classList.remove('hidden');
        });

        document.getElementById('closeThreatFilter').addEventListener('click', () => {
            document.getElementById('threatFilterModal').classList.add('hidden');
        });

        document.getElementById('applyThreatFilter').addEventListener('click', () => {
            document.getElementById('threatFilterModal').classList.add('hidden');
            updateThreatFilterSummary(getDisallowedThreatTypes());
        });

        document.getElementById('selectAllThreats').addEventListener('click', () => {
            const checkboxes = Array.from(document.querySelectorAll('#threatTypeList input[type="checkbox"]'));
            checkboxes.forEach(box => {
                box.checked = true;
            });
            updateThreatFilterSummary(getDisallowedThreatTypes());
        });

        document.getElementById('clearAllThreats').addEventListener('click', () => {
            const checkboxes = Array.from(document.querySelectorAll('#threatTypeList input[type="checkbox"]'));
            checkboxes.forEach(box => {
                box.checked = false;
            });
            updateThreatFilterSummary([]);
        });

        document.getElementById('descriptionFilterBtn').addEventListener('click', () => {
            document.getElementById('descriptionFilterModal').classList.remove('hidden');
        });

        document.getElementById('closeDescriptionFilter').addEventListener('click', () => {
            document.getElementById('descriptionFilterModal').classList.add('hidden');
        });

        document.getElementById('applyDescriptionFilter').addEventListener('click', () => {
            document.getElementById('descriptionFilterModal').classList.add('hidden');
            updateDescriptionFilterSummary(getEnabledDescriptionFilters());
        });

        function closeDangerRevealModal() {
            document.getElementById('dangerRevealModal').classList.add('hidden');
        }

        document.getElementById('closeDangerReveal').addEventListener('click', closeDangerRevealModal);
        document.getElementById('dismissDangerReveal').addEventListener('click', closeDangerRevealModal);

        document.getElementById('selectAllDescriptions').addEventListener('click', () => {
            const checkboxes = Array.from(document.querySelectorAll('#descriptionFilterList input[type="checkbox"]'));
            checkboxes.forEach(box => {
                box.checked = true;
            });
            updateDescriptionFilterSummary(getEnabledDescriptionFilters());
        });

        document.getElementById('clearAllDescriptions').addEventListener('click', () => {
            const checkboxes = Array.from(document.querySelectorAll('#descriptionFilterList input[type="checkbox"]'));
            checkboxes.forEach(box => {
                box.checked = false;
            });
            updateDescriptionFilterSummary([]);
        });

        document.getElementById('dataFile').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;
            
            try {
                const text = await file.text();
                const data = JSON.parse(text);
                
                // Validate required fields
                const required = ['roomTypes', 'leadIns', 'doorStatuses', 'typeWords', 'difficultyProfiles'];
                const missing = required.filter(key => !data[key]);
                
                if (missing.length > 0) {
                    throw new Error(`Missing required fields: ${missing.join(', ')}`);
                }
                
                gameData = data;

                document.getElementById('dataStatus').textContent = `Loaded: ${file.name}`;
                document.getElementById('dataStatus').className = 'data-status loaded';
                document.getElementById('errorDisplay').classList.add('hidden');
                populateAbilityDatalist();
                populateThreatTypeList(getDisallowedThreatTypes());
                updateThreatFilterSummary(getDisallowedThreatTypes());
                populateDescriptionFilterList(getEnabledDescriptionFilters());
                updateDescriptionFilterSummary(getEnabledDescriptionFilters());
                
            } catch (err) {
                document.getElementById('errorDisplay').textContent = `Error loading file: ${err.message}`;
                document.getElementById('errorDisplay').classList.remove('hidden');
                gameData = baseGameData ? JSON.parse(JSON.stringify(baseGameData)) : null;
            }
        });

        document.getElementById('pngFolder').addEventListener('change', (e) => {
            const files = Array.from(e.target.files || []);
            if (files.length === 0) return;
            files.forEach(file => {
                const key = normalizePngPath(file.webkitRelativePath || file.name);
                pngCache[key] = URL.createObjectURL(file);
                missingPngPaths.delete(key);
            });
            updatePngStatus();
            renderMap();
        });

        // ==================== TOOLTIP POSITIONING ====================
        // Position fixed tooltips dynamically based on icon position
        document.addEventListener('mouseenter', (e) => {
            const icon = e.target.closest('.tooltip-icon');
            if (!icon) return;

            const container = icon.closest('.tooltip-container');
            if (!container) return;

            const tooltip = container.querySelector('.tooltip-text');
            if (!tooltip) return;

            const iconRect = icon.getBoundingClientRect();
            const tooltipWidth = 280;
            const tooltipHeight = tooltip.offsetHeight || 100;
            const padding = 8;

            // Try to position to the right of the icon
            let left = iconRect.right + padding;
            let top = iconRect.top + (iconRect.height / 2);

            // If tooltip would go off right edge, position to the left
            if (left + tooltipWidth > window.innerWidth - padding) {
                left = iconRect.left - tooltipWidth - padding;
            }

            // If tooltip would go off left edge, center it above
            if (left < padding) {
                left = Math.max(padding, iconRect.left + (iconRect.width / 2) - (tooltipWidth / 2));
                top = iconRect.top - padding;
                tooltip.style.transform = 'translateY(-100%)';
            } else {
                tooltip.style.transform = 'translateY(-50%)';
            }

            // Keep tooltip within vertical bounds
            const transformedTop = tooltip.style.transform.includes('-100%')
                ? top - tooltipHeight
                : top - (tooltipHeight / 2);

            if (transformedTop < padding) {
                top = padding + (tooltip.style.transform.includes('-100%') ? tooltipHeight : tooltipHeight / 2);
            }
            if (transformedTop + tooltipHeight > window.innerHeight - padding) {
                top = window.innerHeight - padding - tooltipHeight + (tooltip.style.transform.includes('-100%') ? tooltipHeight : tooltipHeight / 2);
            }

            tooltip.style.left = `${left}px`;
            tooltip.style.top = `${top}px`;
        }, true);

        // ==================== INIT ====================
        (async () => {
            await loadBaseGameData();
            populateAbilityDatalist();
            populateThreatTypeList();
            updateThreatFilterSummary(getDisallowedThreatTypes());
            populateDescriptionFilterList([]);
            updateDescriptionFilterSummary([]);
            loadDungeonState();
        })();
    </script>
</body>
</html>
